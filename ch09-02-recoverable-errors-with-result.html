<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Result와 함께하는 복구 가능한 에러 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입들</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수 동작 원리</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 이용해 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install을 이용해 Crates.io에서 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 Cargo 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운팅 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메세지 패싱</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 확장 가능한 동시성: Sync와 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법의 모든 것</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 고급 라이프타임</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 고급 트레잇</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 고급 함수와 클로저</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자 및 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - derive 가능한 트레잇</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 매크로</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 본 책의 번역본 목록</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 새로운 기능</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-glossary.html"><strong aria-hidden="true">21.8.</strong> H - 번역 용어 정리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="result와-함께하는-복구-가능한-에러"><a class="header" href="#result와-함께하는-복구-가능한-에러"><code>Result</code>와 함께하는 복구 가능한 에러</a></h2>
<p>대부분의 에러는 프로그램을 전부 멈추도록 요구될 정도로 심각하지는 않습니다. 종종 어떤 함수가 실패할
때는, 우리가 쉽게 해석하고 대응할 수 있는 이유에 대한 것입니다. 예를 들어, 만일 우리가 어떤 파일을
여는데 해당 파일이 존재하지 않아서 연산에 실패했다면, 프로세스를 멈추는 대신 파일을 새로 만드는
것을 원할지도 모릅니다.</p>
<p>2장의 “<a href="ch02-00-guessing-game-tutorial.html#result-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%9E%A0%EC%9E%AC%EB%90%9C-%EC%8B%A4%ED%8C%A8-%EB%8B%A4%EB%A3%A8%EA%B8%B0"><code>Result</code> 타입으로 잠재된 실패 다루기</a><!-- ignore -->” 절에서
<code>Result</code> 열거형은 다음과 같이 <code>Ok</code>와 <code>Err</code>라는 두 개의 variant를 갖도록 정의되어 있음을
상기하세요:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code>와 <code>E</code>는 제네릭 타입 파라미터입니다; 10장에서 제네릭에 대해 더 자세히 다룰 것입니다. 지금으로서
여러분이 알아둘 필요가 있는 것은, <code>T</code>는 성공한 경우에 <code>Ok</code> variant 내에 반환될 값의 타입을 나타내고
<code>E</code>는 실패한 경우에 <code>Err</code> variant 내에 반환될 에러의 타입을 나타내는 것이라는 점입니다. <code>Result</code>가
이러한 제네릭 타입 파라미터를 갖기 때문에, 우리가 반환하고자 하는 성공적인 값과 에러 값이 다를 수 있는
다양한 상황 내에서 표준 라이브러리에 정의된 <code>Result</code> 타입과 함수들을 사용할 수 있습니다.</p>
<p>실패할 수도 있기 때문에 <code>Result</code> 값을 반환하는 함수를 호출해 봅시다:
Listing 9-3에서는 파일 열기를 시도합니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}</code></pre></pre>
<p><span class="caption">Listing 9-3: 파일 열기</span></p>
<p><code>File::open</code>이 <code>Result</code>를 반환하는지 어떻게 알까요? 표준 라이브러리 API 문서를 찾아보거나,
컴파일러에게 물어볼 수 있습니다! 만일 <code>f</code>에게 우리가 알고 있고 그 함수의 반환 타입은 <em>아닐</em> 어떤 타입에
대한 타입 명시를 주고 그 코드의 컴파일을 시도한다면, 컴파일러는 우리에게 타입이 맞지 않는다고
알려줄 것입니다. 그 후 에러 메세지는 <code>f</code>의 타입이 <em>무엇인지</em> 알려줄 것입니다. 한번 해봅시다:
우리는 <code>File::open</code>의 반환 타입이 <code>u32</code>는 아니라는 것을 알고 있으니, <code>let f</code> 구문을 이렇게
바꿔봅시다:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);</code></pre>
<p>이제 컴파일을 시도하면 다음 메세지가 나타납니다:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  = note:    found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>이 메세지는 <code>File::open</code> 함수의 반환 타입이 <code>Result&lt;T, E&gt;</code>라는 것을 알려줍니다. 여기서 제네릭
파라미터 <code>T</code>는 성공값의 타입인 <code>std::fs::File</code>로 채워져 있는데, 이것은 파일 핸들입니다. 에러에
사용되는 <code>E</code>의 타입은 <code>std::io::Error</code>입니다.</p>
<p>이 반환 타입은 <code>File::open</code>을 호출하는 것이 성공하여 우리가 읽거나 쓸 수 있는 파일 핸들을 반환해
줄 수도 있다는 뜻입니다. 함수 호출은 또한 실패할 수도 있습니다: 예를 들면 파일이 존재하지 않거나
파일에 접근할 권한이 없을지도 모릅니다. <code>File::open</code> 함수는 우리에게 성공했는지 혹은 실패했는지를
알려주면서 동시에 파일 핸들이나 에러 정보 둘 중 하나를 우리에게 제공할 방법을 가질 필요가 있습니다.
바로 이러한 정보가 <code>Result</code> 열거형이 전달하는 것과 정확히 일치합니다.</p>
<p><code>File::open</code>이 성공한 경우, 변수 <code>f</code>가 가지게 될 값은 파일 핸들을 담고 있는 <code>Ok</code> 인스턴스가
될 것입니다. 실패한 경우, <code>f</code>의 값은 발생한 에러의 종류에 대한 더 많은 정보를 가지고 있는 <code>Err</code>의
인스턴스가 될 것입니다.</p>
<p>우리는 Listing 9-3의 코드에 <code>File::open</code>이 반환하는 값에 따라 다른 행동을 취하는 코드를 추가할
필요가 있습니다. Listing 9-4은 우리가 6장에서 다뤘던 기초 도구 <code>match</code> 표현식을 이용하여
<code>Result</code>를 처리하는 한 가지 방법을 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}</code></pre></pre>
<p><span class="caption">Listing 9-4: <code>match</code> 표현식을 사용하여 발생 가능한 <code>Result</code>
variant들을 처리하기</span></p>
<p><code>Option</code> 열거형과 같이 <code>Result</code> 열거형과 variant들은 프렐루드(prelude)로부터 가져와진다는 점을
기억하세요. 따라서 <code>match</code>의 각 경우에 대해서 <code>Ok</code>와 <code>Err</code> 앞에 <code>Result::</code>를 특정하지 않아도
됩니다.</p>
<p>여기서 우리는 러스트에게 결과가 <code>Ok</code>일 때에는 <code>Ok</code> variant로부터 내부의 <code>file</code> 값을 반환하고,
이 파일 핸들 값을 변수 <code>f</code>에 대입한다고 말해주고 있습니다. <code>match</code> 이후에는 읽거나 쓰기 위해
이 파일 핸들을 사용할 수 있습니다.</p>
<p><code>match</code>의 다른 경우는 <code>File::open</code>으로부터 <code>Err</code>를 얻은 경우를 처리합니다. 이 예제에서는
<code>panic!</code> 매크로를 호출하는 방법을 택했습니다. 우리의 현재 디렉토리 내에 <em>hello.txt</em>라는 이름의
파일이 없는데 이 코드를 실행하게 되면, <code>panic!</code> 매크로로부터 다음과 같은 출력을 보게 될 것입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
</code></pre>
<p>늘 그렇듯이, 이 출력은 어떤 것이 잘못되었는지 정확히 알려줍니다.</p>
<h3 id="서로-다른-에러에-대해-매칭하기"><a class="header" href="#서로-다른-에러에-대해-매칭하기">서로 다른 에러에 대해 매칭하기</a></h3>
<p>Listing 9-3의 코드는 <code>File::open</code>이 실패한 이유가 무엇이든 간에 <code>panic!</code>을 일으킬 것입니다.
대신 우리가 원하는 것은 실패 이유에 따라 다른 행동을 취하는 것입니다: 파일이 없어서
<code>File::open</code>이 실패한 것이라면, 새로운 파일을 만들어서 핸들을 반환하고 싶습니다. 만일 그 밖의
이유로 <code>File::open</code>이 실패한 거라면, 예를 들어 파일을 열 권한이 없어서라면,
Listing 9-4에서 했던 것과 마찬가지로 <code>panic!</code>을 일으키고
싶습니다. <code>match</code>에 새로운 경우를 추가한 Listing 9-5를 봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}</code></pre>
<p><span class="caption">Listing 9-5: 다른 종류의 에러를 다른 방식으로 처리하기</span></p>
<p><code>Err</code> variant 내에 있는 <code>File::open</code>이 반환하는 값의 타입은 <code>io::Error</code>인데, 이는
표준 라이브러리에서 제공하는 구조체입니다. 이 구조체는 <code>kind</code> 메소드를 제공하는데 이를 호출하여
<code>io::ErrorKind</code>값을 얻을 수 있습니다. <code>io::ErrorKind</code>는 <code>io</code> 연산으로부터 발생할 수 있는
여러 종류의 에러를 표현하는 variant를 가진, 표준 라이브러리에서 제공하는 열거형입니다. 우리가
사용하고자 하는 variant는 <code>ErrorKind::NotFound</code>인데, 이는 열고자 하는 파일이 아직 존재하지
않음을 나타냅니다.</p>
<p>조건문 <code>if error.kind() == ErrorKind::NotFound</code>는 <em>매치 가드(match guard)</em> 라고
부릅니다: 이는 <code>match</code> 줄기 상에서 줄기의 패턴을 좀 더 정제해주는 추가 조건문입니다. 그 줄기의 코드가
실행되기 위해서는 이 조건문이 참이어야 합니다; 그렇지 않다면, 패턴 매칭은 <code>match</code>의 다음 줄기에
맞춰보기 위해 이동할 것입니다. 패턴에는 <code>ref</code>가 필요하며 그럼으로써 <code>error</code>가 가드 조건문으로
소유권 이동이 되지 않고 그저 참조만 됩니다. 패턴 내에서 참조자를 얻기 위해 <code>&amp;</code>대신 <code>ref</code>이 사용되는
이유는 18장에서 자세히 다룰 것입니다. 짧게 설명하면, <code>&amp;</code>는 참조자를 매치하고 그 값을 제공하지만,
<code>ref</code>는 값을 매치하여 그 참조자를 제공합니다.</p>
<p>매치 가드 내에서 확인하고자 하는 조건문은 <code>error.kind()</code>에 의해 반환된 값이 <code>ErrorKind</code> 열거형의
<code>NotFound</code> variant인가 하는 것입니다. 만일 그렇다면, <code>File::create</code>로 파일 생성을 시도합니다.
그러나, <code>File::create</code> 또한 실패할 수 있기 때문에, 안쪽에 <code>match</code> 구문을 바깥쪽과 마찬가지로 추가할
필요가 있습니다. 파일이 열 수 없을 때, 다른 에러 메세지가 출력될 것입니다. 바깥쪽 <code>match</code>의 마지막 갈래는
똑같이 남아서, 파일을 못 찾는 에러 외에 다른 어떤 에러에 대해서도 패닉을 일으킵니다.</p>
<h3 id="에러가-났을-때-패닉을-위한-숏컷-unwrap과-expect"><a class="header" href="#에러가-났을-때-패닉을-위한-숏컷-unwrap과-expect">에러가 났을 때 패닉을 위한 숏컷: <code>unwrap</code>과 <code>expect</code></a></h3>
<p><code>match</code>의 사용은 충분히 잘 동작하지만, 살짝 장황하기도 하고 의도를 항상 잘 전달하는 것도 아닙니다.
<code>Result&lt;T, E&gt;</code> 타입은 다양한 작업을 하기 위해 정의된 수많은 헬퍼 메소드를 가지고 있습니다. 그 중
하나인 <code>unwrap</code> 이라 부르는 메소드는 Listing 9-4에서 작성한 <code>match</code> 구문과 비슷한 구현을 한 숏컷
메소드입니다. 만일 <code>Result</code> 값이 <code>Ok</code> variant라면, <code>unwrap</code>은 <code>Ok</code> 내의 값을 반환할 것입니다.
만일 <code>Result</code>가 <code>Err</code> variant라면, <code>unwrap</code>은 우리를 위해 <code>panic!</code> 매크로를 호출할 것입니다.
아래에 <code>unwrap</code>이 작동하는 예가 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}</code></pre></pre>
<p><em>hello.txt</em> 파일이 없는 상태에서 이 코드를 실행시키면, <code>unwrap</code> 메소드에 의한 <code>panic!</code>
호출로부터의 에러 메세지를 보게 될 것입니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>또 다른 메소드인 <code>expect</code>는 <code>unwrap</code>과 유사한데, 우리가 <code>panic!</code> 에러 메세지를 선택할 수 있게
해줍니다. <code>unwrap</code>대신 <code>expect</code>를 이용하고 좋은 에러 메세지를 제공하는 것은 여러분의 의도를
전달해주고 패닉의 근원을 추적하는 걸 쉽게 해 줄 수 있습니다. <code>expect</code>의 문법은 아래와 같이
생겼습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}</code></pre></pre>
<p><code>expect</code>는 <code>unwrap</code>과 같은 식으로 사용됩니다: 파일 핸들을 리턴하거나 <code>panic!</code> 매크로를 호출하는
것이죠. <code>expect</code>가 <code>panic!</code> 호출에 사용하는 에러 메세지는 <code>unwrap</code>이 사용하는 기본 <code>panic!</code>
메세지보다는 <code>expect</code>에 넘기는 파라미터로 설정될 것입니다. 아래에 어떻게 생겼는지에 대한 예가 있습니다:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>이 에러 메세지는 우리가 특정한 텍스트인 <code>Failed to open hello.txt</code>로 시작하기 때문에, 이 에러 메세지가
어디서부터 왔는지를 코드 내에서 찾기가 더 수월해질 것입니다. 만일 우리가 여러 군데에 <code>unwrap</code>을 사용하면,
정확히 어떤 <code>unwrap</code>이 패닉을 일으켰는지 찾기에 좀 더 많은 시간이 걸릴 수 있는데, 그 이유는 패닉을
호출하는 모든 <code>unwrap</code>이 동일한 메세지를 출력하기 때문입니다.</p>
<h3 id="에러-전파하기"><a class="header" href="#에러-전파하기">에러 전파하기</a></h3>
<p>실패할지도 모르는 무언가를 호출하는 구현을 가진 함수를 작성할 때, 이 함수 내에서 에러를 처리하는 대신,
에러를 호출하는 코드 쪽으로 반환하여 그쪽에서 어떻게 할지 결정하도록 할 수 있습니다. 이는 에러
<em>전파하기</em>로 알려져 있으며, 에러가 어떻게 처리해야 좋을지 좌우해야 할 상황에서, 여러분의 코드 내용 내에서
이용 가능한 것들보다 더 많은 정보와 로직을 가지고 있을 수도 있는 호출하는 코드 쪽에 더 많은 제어권을 줍니다.</p>
<p>예를 들면, Listing 9-6은 파일로부터 사용자 이름을 읽는 함수를 작성한 것입니다. 만일 파일이 존재하지
않거나 읽을 수 없다면, 이 함수는 호출하는 코드 쪽으로 해당 에러를 반환할 것입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-6: <code>match</code>를 이용하여 호출 코드 쪽으로 에러를 반환하는 함수
</span></p>
<p>함수의 반환 타입부터 먼저 살펴봅시다: <code>Result&lt;String, io::Error&gt;</code>. 이는 함수가 <code>Result&lt;T, E&gt;</code>
타입의 값을 반환하는데 제네릭 파라미터 <code>T</code>는 구체적 타입(concrete type)인 <code>String</code>로 채워져 있고,
제네릭 타입 <code>E</code>는 구체적 타입인 <code>io::Error</code>로 채워져 있습니다. 만일 이 함수가 어떤 문제 없이 성공하면,
함수를 호출한 코드는 <code>String</code>을 담은 값을 받을 것입니다 - 이 함수가 파일로부터 읽어들인 사용자
이름이겠지요. 만일 어떤 문제가 발생한다면, 이 함수를 호출한 코드는 문제가 무엇이었는지에 대한 더 많은
정보를 담고 있는 <code>io::Error</code>의 인스턴스를 담은 <code>Err</code> 값을 받을 것입니다. 이 함수의 반환 타입으로서
<code>io::Error</code>를 선택했는데, 그 이유는 우리가 이 함수 내부에서 호출하고 있는 실패 가능한 연산 두 가지가
모두 이 타입의 에러 값을 반환하기 때문입니다: <code>File::open</code> 함수와 <code>read_to_string</code> 메소드 말이죠.</p>
<p>함수의 본체는 <code>File::open</code> 함수를 호출하면서 시작합니다. 그다음에는 Listing 9-4에서 본 <code>match</code>와
유사한 식으로 <code>match</code>을 이용해서 <code>Result</code> 값을 처리하는데, <code>Err</code> 경우에 <code>panic!</code>을 호출하는 대신
이 함수를 일찍 끝내고 <code>File::open</code>으로부터의 에러 값을 마치 이 함수의 에러 값인 것처럼 호출하는 쪽의
코드에게 전달합니다. 만일 <code>File::open</code>이 성공하면, 파일 핸들을 <code>f</code>에 저장하고 계속합니다.</p>
<p>그 뒤 변수 <code>s</code>에 새로운 <code>String</code>을 생성하고 파일의 콘텐츠를 읽어 <code>s</code>에 넣기 위해 <code>f</code>에 있는
파일 핸들의 <code>read_to_string</code> 메소드를 호출합니다. <code>File::open</code>가 성공하더라도 <code>read_to_string</code>
메소드가 실패할 수 있기 때문에 이 함수 또한 <code>Result</code>를 반환합니다. 따라서 이 <code>Result</code>를 처리하기
위해서 또 다른 <code>match</code>가 필요합니다: 만일 <code>read_to_string</code>이 성공하면, 우리의 함수가 성공한
것이고, 이제 <code>s</code> 안에 있는 파일로부터 읽어들인 사용자 이름을 <code>Ok</code>에 싸서 반환합니다. 만일
<code>read_to_string</code>이 실패하면, <code>File::open</code>의 반환값을 처리했던 <code>match</code>에서 에러값을
반환하는 것과 같은 방식으로 에러 값을 반환합니다. 하지만 여기서는 명시적으로 <code>return</code>이라 말할
필요는 없는데, 그 이유는 이 함수의 마지막 표현식이기 때문입니다.</p>
<p>그러면 이 코드를 호출하는 코드는 사용자 이름을 담은 <code>Ok</code> 값 혹은 <code>io::Error</code>를 담은 <code>Err</code> 값을
얻는 처리를 하게 될 것입니다. 호출하는 코드가 이 값을 가지고 어떤 일을 할 것인지 우리는 알지 못합니다.
만일 그쪽에서 <code>Err</code> 값을 얻었다면, 예를 들면 <code>panic!</code>을 호출하여 프로그램을 종료시키는 선택을 할
수도 있고, 기본 사용자 이름을 사용할 수도 있으며, 혹은 파일이 아닌 다른 어딘가에서 사용자 이름을
찾을 수도 있습니다. 호출하는 코드가 정확히 어떤 것을 시도하려 하는지에 대한 충분한 정보가 없기 때문에,
우리는 모든 성공 혹은 에러 정보를 위로 전파하여 호출하는 코드가 적절하게 처리를 하도록 합니다.</p>
<p>러스트에서 에러를 전파하는 패턴은 너무 흔하여 러스트에서는 이를 더 쉽게 해주는 물음표 연산자 <code>?</code>를
제공합니다.</p>
<h3 id="에러를-전파하기-위한-숏컷-"><a class="header" href="#에러를-전파하기-위한-숏컷-">에러를 전파하기 위한 숏컷: <code>?</code></a></h3>
<p>Listing 9-7은 Listing 9-6과 같은 기능을 가진 <code>read_username_from_file</code>의 구현을 보여주는데,
다만 이 구현은 물음표 연산자를 이용하고 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-7: <code>?</code>를 이용하여 에러를 호출하는 코드 쪽으로 반환하는 함수</span></p>
<p><code>Result</code> 값 뒤의 <code>?</code>는 Listing 9-6에서 <code>Result</code> 값을 다루기 위해 정의했던 <code>match</code> 표현식과
거의 같은 방식으로 동작하게끔 정의되어 있습니다. 만일 <code>Result</code>의 값이 <code>Ok</code>라면, <code>Ok</code> 내의 값이
이 표현식으로부터 얻어지고 프로그램이 계속됩니다. 만일 값이 <code>Err</code>라면, 우리가 <code>return</code> 키워드를
사용하여 에러 값을 호출하는 코드에게 전파하는 것과 같이 전체 함수로부터 <code>Err</code> 내의 값이 반환될
것입니다.</p>
<p>Listing 9-6에 있는 <code>match</code> 표현식과 물음표 연산자가 수행하는 한 가지 차이점은 물음표 연산자를
사용할 때 에러 값들이 표준 라이브러리 내에 있는 <code>From</code> 트레잇에 정의된 <code>from</code> 함수를 친다는
것입니다. 많은 에러 타입들이 어떤 타입의 에러를 다음 타입의 에러로 변환하기 위해 <code>from</code> 함수를
구현하였습니다. 물음표 연산자가 사용되면, <code>from</code> 함수의 호출이 물음표 연산자가 얻게 되는 에러
타입을 <code>?</code>이 사용되고 있는 현재 함수의 반환 타입에 정의된 에러 타입으로 변환합니다. 이는
어떤 함수의 부분들이 수많은 다른 이유로 인해 실패할 수 있지만 이 함수는 실패하는 모든 방식을
하나의 에러 타입으로 반환할 때 유용합니다. 각각의 에러 타입이 그 자신을 반환되는 에러 타입으로
변경할 방법을 정의하기 위해 <code>from</code> 함수를 구현하기만 한다면, 물음표 연산자는 이 변환을 자동적으로
다룹니다.</p>
<p>Listing 9-7의 내용에서, <code>File::open</code> 호출 부분의 끝에 있는 <code>?</code>는 <code>Ok</code>내의 값을 변수 <code>f</code>에게
반환해줄 것입니다. 만일 에러가 발생하면 <code>?</code>는 전체 함수로부터 일찍 빠져나와 호출하는 코드에게
어떤 <code>Err</code> 값을 줄 것입니다. <code>read_to_string</code> 호출의 끝부분에 있는 <code>?</code>도 같은 것이 적용되어
있습니다.</p>
<p><code>?</code>는 많은 수의 보일러플레이트(boilerplate)를 제거해주고 이 함수의 구현을 더 단순하게 만들어 줍니다.
심지어는 Listing 9-8과 같이 <code>?</code> 뒤에 바로 메소드 호출을 연결하는 식으로 (chaining) 이 코드를 더
줄일 수도 있습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 9-8: 물음표 연산자 뒤에 메소드 호출을 연결하기</span></p>
<p>새로운 <code>String</code>을 만들어 <code>s</code>에 넣는 부분을 함수의 시작 부분으로 옮겼습니다; 이 부분은 달라진 것이
없습니다. <code>f</code> 변수를 만드는 대신, <code>File::open(&quot;hello.txt&quot;)?</code>의 결과 바로 뒤에
<code>read_to_string</code>의 호출을 연결시켰습니다. <code>read_to_string</code> 호출의 끝에는 여전히 <code>?</code>가
남아있고, <code>File::open</code>과 <code>read_to_string</code>이 모두 에러를 반환하지 않고 성공할 때
<code>s</code> 안의 사용자 이름을 담은 <code>Ok</code>를 여전히 반환합니다. 함수의 기능 또한 Lsting 9-6과
Listing 9-7의 것과 동일하고, 다만 작성하기에 더 인체공학적인 방법이라는 차이만 있을 뿐입니다.</p>
<h3 id="는-result를-반환하는-함수에서만-사용될-수-있습니다"><a class="header" href="#는-result를-반환하는-함수에서만-사용될-수-있습니다"><code>?</code>는 <code>Result</code>를 반환하는 함수에서만 사용될 수 있습니다</a></h3>
<p><code>?</code>는 <code>Result</code> 타입을 반환하는 함수에서만 사용이 가능한데, 이것이 Listing 9-6에 정의된 <code>match</code>
표현식과 동일한 방식으로 동작하도록 정의되어 있기 때문입니다. <code>Result</code> 반환 타입을 요구하는
<code>match</code> 부분은 <code>return Err(e)</code>이며, 따라서 함수의 반환 타입은 반드시 이 <code>return</code>과 호환 가능한
<code>Result</code>가 되어야 합니다.</p>
<p><code>main</code>의 반환 타입이 <code>()</code>라는 것을 상기하면서, 만약 <code>main</code> 함수 내에서 <code>?</code>를 사용하면 어떤일이 생길지
살펴봅시다:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}</code></pre>
<p>이걸 컴파일하면, 아래와 같은 에러 메세지가 뜹니다:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns
`Result` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             cannot use the `?` operator in a function that returns `()`
  |             in this macro invocation
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>이 에러는 오직 <code>Result</code>를 반환하는 함수 내에서만 물음표 연산자를 사용할 수 있음을 지적합니다.
<code>Result</code>를 반환하지 않는 함수 내에서, 여러분이 <code>Result</code>를 반환하는 다른 함수를 호출했을 때,
여러분은 <code>?</code>를 사용하여 호출하는 코드에게 잠재적으로 에러를 전파하는 대신 <code>match</code>나 <code>Result</code>에서
제공하는 메소드들 중 하나를 사용하여 이를 처리할 필요가 있을 것입니다.</p>
<p><code>panic!</code>을 호출하거나 <code>Result</code>를 반환하는 것의 자세한 부분을 논의했으니, 어떤 경우에 어떤 방법을
사용하는 것이 적합할지를 어떻게 결정하는가에 대한 주제로 돌아갑시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
