<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt;와 내부 가변성 패턴 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입들</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수 동작 원리</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 이용해 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install을 이용해 Crates.io에서 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 Cargo 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운팅 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html" class="active"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메세지 패싱</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 확장 가능한 동시성: Sync와 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법의 모든 것</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 고급 라이프타임</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 고급 트레잇</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 고급 함수와 클로저</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자 및 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - derive 가능한 트레잇</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 매크로</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 본 책의 번역본 목록</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 새로운 기능</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-glossary.html"><strong aria-hidden="true">21.8.</strong> H - 번역 용어 정리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt와-내부-가변성-패턴"><a class="header" href="#refcellt와-내부-가변성-패턴"><code>RefCell&lt;T&gt;</code>와 내부 가변성 패턴</a></h2>
<p><em>내부 가변성 (interior mutability)</em> 은 어떤 데이터에 대한 불변 참조자가 있을
때라도 여러분이 데이터를 변형할 수 있게 해주는 러스트의 디자인 패턴입니다: 보통 이러한
동작은 빌림 규칙에 의해 허용되지 않습니다. 그렇게 하기 위해서, 이 패턴은 변형과 빌림을
지배하는 러스트의 통상적인 규칙을 구부리기 위하여 데이터 구조 내에서 <code>unsafe (안전하지 않은)</code> 코드를 사용합니다. 우리는 아직 안전하지 않은 코드를 다루지 않았습니다; 이는
19장에서 다룰 것입니다. 우리가 런타임에 빌림 규칙을 따를 것임을 보장할 수 있을 때라면,
심지어 컴파일러가 이를 보장하지 못하더라도 내부 가변성 패턴을 이용하는 타입을 사용할 수
있습니다. 포함되어 있는 <code>unsafe</code> 코드는 안전한 API로 감싸져 있고, 외부 타입은
여전히 불변입니다.</p>
<p>내부 가변성 패턴을 따르는 <code>RefCell&lt;T&gt;</code> 타입을 살펴보는 것으로 이 개념을
탐구해 봅시다.</p>
<h3 id="refcellt을-가지고-런타임에-빌림-규칙을-집행하기"><a class="header" href="#refcellt을-가지고-런타임에-빌림-규칙을-집행하기"><code>RefCell&lt;T&gt;</code>을 가지고 런타임에 빌림 규칙을 집행하기</a></h3>
<p><code>Rc&lt;T&gt;</code>와는 다르게, <code>RefCell&lt;T&gt;</code> 타입은 가지고 있는 데이터 상에 단일 소유권을
나타냅니다. 그렇다면, <code>Box&lt;T&gt;</code>와 같은 타입에 비교해 <code>RefCell&lt;T&gt;</code>의 다른 부분은
무엇일까요? 여러분이 4장에서 배웠던 빌림 규칙을 상기해보세요:</p>
<ul>
<li>어떠한 경우이든 간에, 여러분은 다음의 둘 다는 아니고 <em>둘 중 하나만</em> 가질 수 있습니다:
하나의 가변 참조자 혹은 임의 개수의 불변 참조자들을요.</li>
<li>참조자는 항상 유효해야 합니다.</li>
</ul>
<p>참조자와 <code>Box&lt;T&gt;</code>를 이용할 때, 빌림 규칙의 불변성은 컴파일 타임에 집행됩니다.
<code>RefCell&lt;T&gt;</code>를 이용할 때, 이 불변성은 <em>런타임에</em> 집행됩니다. 참조자를 가지고서
여러분이 이 규칙을 어기면 컴파일러 에러를 얻게 될 것입니다. <code>RefCell&lt;T&gt;</code>를 가지고서
여러분이 이 규칙을 어기면, 여러분의 프로그램은 <code>panic!</code>을 일으키고 종료될 것입니다.</p>
<p>컴파일 타임에 빌림 규칙을 검사하는 것은 개발 과정에서 에러를 더 일찍 잡을 수
있다는 점, 그리고 이 모든 분석이 사전에 완료되기 때문에 런타임 성능에 영향이
없다는 점에서 장점을 가집니다. 이러한 까닭에, 대부분의 경우 컴파일 타임에서
빌림 규칙을 검사하는 것이 가장 좋은 선택이고, 이것이 러스트의 기본 설정인
이유이기도 합니다.</p>
<p>대신 런타임에 빌림 규칙을 검사하는 것은 컴파일 타임 검사에 의해서는 허용되지
않는, 특정한 메모리 안정성 시나리오가 허용된다는 잇점이 있습니다. 러스트
컴파일러와 같은 정적 분석은 태생적으로 보수적입니다. 어떤 코드 속성은
코드의 분석을 이용해서는 발견이 불가능합니다: 가장 유명한 예제는 정지 문제
(halting problem) 인데, 이는 이 책의 범위를 벗어나지만 연구하기에
흥미로운 주제입니다.</p>
<p>몇몇 분석이 불가능하기 때문에, 만일 코드가 소유권 규칙을 준수한다는 것을 러스트
컴파일러가 확신할 수 없다면, 컴파일러는 올바른 프로그램을 거부할지도 모릅니다;
이렇게 하여, 컴파일러는 보수적입니다. 만일 러스트가 올바르지 않은 프로그램을
받아들이면, 사용자들은 러스트가 보장하는 것을 신뢰할 수 없을 것입니다. 하지만,
만일 러스트가 올바른 프로그램을 거부한다면, 프로그래머는 불편해할 것이지만,
어떠한 재앙도 일어나지 않을 수 있습니다. <code>RefCell&lt;T&gt;</code> 타입은 여러분의 코드가
빌림 규칙을 따르는 것을 여러분이 확신하지만, 컴파일러는 이를 이해하고 보장할 수
없을 경우 유용합니다.</p>
<p><code>Rc&lt;T&gt;</code>와 유사하게, <code>RefCell&lt;T&gt;</code>은 단일 스레드 시나리오 내에서만 사용
가능하고, 만일 여러분이 이를 다중 스레드 맥락 내에서 사용을 시도할 경우 여러분에게
컴파일 타임 에러를 줄 것입니다. <code>RefCell&lt;T&gt;</code>의 기능을 다중 스레드 프로그램
내에서 사용하는 방법에 대해서는 16장에서 이야기할 것입니다.</p>
<p><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, 혹은 <code>RefCell&lt;T&gt;</code>을 선택하는 이유의 요점은 다음과 같습니다:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>는 동일한 데이터에 대해 복수개의 소유자를 가능하게 합니다; <code>Box&lt;T&gt;</code>와
<code>RefCell&lt;T&gt;</code>은 단일 소유자만 갖습니다.</li>
<li><code>Box&lt;T&gt;</code>는 컴파일 타임에 검사된 불변 혹은 가변 빌림을 허용합니다; <code>Rc&lt;T&gt;</code>는
오직 컴파일 타임에 검사된 불변 빌림만 허용합니다; <code>RefCell&lt;T&gt;</code>는 런타임에
검사된 불변 혹은 가변 빌림을 허용합니다.</li>
<li><code>RefCell&lt;T&gt;</code>이 런타임에 검사된 가변 빌림을 허용하기 때문에, <code>RefCell&lt;T&gt;</code>이
불변일 때라도 <code>RefCell&lt;T&gt;</code> 내부의 값을 변경할 수 있습니다.</li>
</ul>
<p>불변값 내부의 값을 변경하는 것을 <em>내부 가변성</em> 패턴이라고 합니다.
내부 가변성이 유용한 경우를 살펴보고 이것이 어떻게 가능한지 조사해
봅시다.</p>
<h3 id="내부-가변성-불변값에-대한-가변-빌림"><a class="header" href="#내부-가변성-불변값에-대한-가변-빌림">내부 가변성: 불변값에 대한 가변 빌림</a></h3>
<p>빌림 규칙의 결과로 인해 우리는 불변값을 가지고 있을 때 이를 변경 가능하게
빌릴 수 없습니다. 예를 들면, 다음 코드는 컴파일되지 않을 것입니다:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>이 코드의 컴파일을 시도하면, 다음과 같은 에러를 얻을 것입니다:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<p>하지만, 값이 자신의 메소드 내부에서 변경되지만 다른 코드에서는 불변인
것으로 보이는 것이 유용할 수 있는 경우가 있습니다. 그 값의 메소드 바깥의
코드는 값을 변경할 수 없을 것입니다. <code>RefCell&lt;T&gt;</code>을 이용하는 것은
내부 가변성의 기능을 얻는 한가지 방법입니다. 그러나 <code>RefCell&lt;T&gt;</code>은
빌림 규칙을 완벽하게 피하는 것은 아닙니다: 컴파일러 내의 빌림 검사기는
이러한 내부 가변성을 허용하고, 빌림 규칙은 대신 런타임에 검사됩니다.
만일 이 규칙을 위반하면, 우리는 컴파일러 에러 대신 <code>panic!</code>을 얻을
것입니다.</p>
<p>불변 값을 변경하기 위해 <code>RefCell&lt;T&gt;</code>를 이용할 수 있는 실질적인 예제를
살펴보고 이것이 왜 유용한지를 알아봅시다.</p>
<h4 id="내부-가변성에-대한-용례-목mock-객체"><a class="header" href="#내부-가변성에-대한-용례-목mock-객체">내부 가변성에 대한 용례: 목(mock) 객체</a></h4>
<p><em>테스트 더블 (test double)</em> 은 테스트하는 동안 또다른 타입을 대신하여
사용되는 타입을 위한 일반적인 프로그래밍 개념입니다. <em>목 객체 (mock object)</em>
는 테스트 중 어떤 일이 일어났는지 기록하여 정확한 동작이 일어났음을 단언할 수
있도록 하는 테스트 더블의 특정한 타입입니다.</p>
<p>러스트는 다른 언어들이 객체를 가지는 것과 동일한 의미의 객체를 가지고 있지
않고, 러스트는 몇몇 다른 언어들이 제공하는 것 같은 표준 라이브러리에 미리
만들어진 목 객체 기능이 없습니다. 하지만, 우리는 목 객체와 동일한 목적을
제공할 구조체를 당연히 만들 수 있습니다.</p>
<p>다음은 우리가 테스트할 시나리오입니다: 우리는 최대값에 맞서 값을 추적하고
현재 값이 최대값에 얼마나 근접한지를 기반으로 메세지를 전송하는 라이브러리를
만들 것입니다. 이 라이브러리는 예를 들면 한 명의 유저에게 허용되고 있는
API 호출수의 허용량을 추적하는데 사용될 수 있습니다.</p>
<p>우리의 라이브러리는 오직 어떤 값이 최대값에 얼마나 근접한지를 추적하고 어떤 시간에
어떤 메세지를 보내야 할지 정하는 기능만을 제공할 것입니다. 우리의 라이브러리를 사용하는
어플리케이션이 메세지를 전송하는 것에 대한 메카니즘을 제공할 예정입니다: 그 어플리케이션은
메세지를 어플리케이션 내에 집어넣거나, 이메일을 보내거나, 문자 메세지를 보내거나, 혹은
기타 다른 것을 할 수 있습니다. 라이브러리는 그런 자세한 사항을 알 필요가 없습니다. 필요한
모든 것은 우리가 제공할 <code>Messenger</code>라는 이름의 트레잇을 구현하는 것입니다. Listing
15-20는 라이브러리 코드를 보여줍니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 15-20: 어떤 값이 최대값에 얼마나 근접하는지를
추적하고 특정 수준에 값이 있으면 경고해주는 라이브러리</span></p>
<p>이 코드에서 한가지 중요한 부분은 <code>Messenger</code> 트레잇이 <code>self</code>에 대한
불변 참조자와 메세지의 텍스트를 인자로 갖는 <code>send</code>라는 이름의 하나의
메소드를 갖고 있다는 것입니다. 이는 우리의 목 객체가 가질 필요가 있는
인터페이스입니다. 그 외에 중요한 부분은 우리가 <code>LimitTracker</code> 상의
<code>set_value</code> 메소드의 동작을 테스트하고 싶어한다는 점입니다. 우리는
<code>value</code> 파라미터에 대해에 어떤 것을 넘길지 바꿀 수 있지만,
<code>set_value</code>는 우리가 단언을 하기 위한 어떤 것도 반환하지 않습니다.
우리는 <code>Messenger</code> 트레잇을 구현한 무언가와 <code>max</code>에 대한 특정값과 함께
<code>LimitTracker</code>를 만든다면, <code>value</code>에 대해 다른 숫자들을 넘겼을 때
메신저가 적합한 메세지를 보낸다고 말하고 싶습니다.</p>
<p>우리는 <code>send</code>를 호출했을 때 메일이나 텍스트 메세지를 보내는 대신 보냈다고
언급하는 메세지만 추적할 목 객체가 필요합니다. 우리는 목 객체의 새로운 인스턴스를
만들고, 이 목 객체를 사용하는 <code>LimitTracker</code>를 만들고, <code>LimitTracker</code>
상의 <code>set_value</code> 메소드를 호출하고, 그 다음 목 객체는 우리가 기대했던
메세지를 가지고 있는지를 검사할 수 있습니다.  Listing 15-21은 바로 이런
일을 하지만 빌림 검사기가 허용하지는 않을 목 객체 구현 시도를 보여주고
있습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 15-21: 빌림 검사기가 허용하지 않는
<code>MockMessenger</code> 구현 시도</span></p>
<p>이 테스트 코드는 보내질 메세지들을 추적하기 위한 <code>String</code> 값의 <code>Vec</code>인
<code>sent_messages</code> 필드를 갖는 <code>MockMessenger</code> 구조체를 정의하고
있습니다. 우리는 또한 빈 메세지 리스트로 시작하는 새로운 <code>MockMessenger</code>
값을 생성하기 쉽도록 하기 위해 연관 함수 <code>new</code>를 정의하였습니다. 그런
다음에는 <code>MockMessenger</code>를 <code>LimitTracker</code>에 넘겨줄 수 있도록
<code>MockMessenger</code>를 위한 <code>Messenger</code> 트레잇을 구현하였습니다. <code>send</code>
메소드의 정의 부분에서는 파라미터로서 넘겨진 메세지를 가져와서 <code>MockMessenger</code>
내의 <code>sent_messages</code> 리스트에 저장합니다.</p>
<p>테스트 내에서는 <code>max</code> 값의 75 퍼센트 이상의 무언가가 <code>value</code>로 설정되었을
때 <code>LimitTracker</code>는 어떤 메세지를 듣는지를 테스트하고 있습니다. 먼저 우리는
새로운 <code>MockMessenger</code>를 만드는데, 이는 비어있는 메시지 리스트로 시작할
것입니다. 그 다음에는 새로운 <code>LimitTracker</code>를 만들고 여기에 새로운
<code>MockMessenger</code>의 참조자와 <code>max</code>값 100을 파라미터로 넘깁니다. 우리는
<code>LimitTracker</code> 상의 <code>set_value</code> 메소드를 80 값으로 호출하였습니다.
그 다음 우리는 <code>MockMessenger</code>가 추적하고 있는 메세지 리스트가 이제
한 개의 메세지를 가지고 있는지를 검사합니다.</p>
<p>하지만, 아래에서 보는 것과 같이 이 테스트에 한가지 문제점이 있습니다:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<p>우리는 메세지를 추적하기 위해 <code>MockMessenger</code>를 수정할 수 없는데 그 이유는
<code>send</code> 메소드가 <code>self</code>의 불변 참조자를 파라미터로 갖기 때문입니다. 우리는 또한
에러 메세지로부터 <code>&amp;mut self</code>를 대신 사용하라는 제안도 얻을 수 없는데, 그렇게
되면 <code>send</code>의 시그니처가 <code>Messenger</code> 트레잇의 정의에 있는 시그니처와 일치하지
않을 것이지 때문입니다 (마음 편하게 한번 시도해보고 어떤 에러가 나오는지 보세요).</p>
<p>이는 내부 가변성이 도움을 줄 수 있는 상황입니다! 우리는 <code>sent_messages</code>를
<code>RefCell&lt;T&gt;</code> 내에 저장할 것이고, 그러면 <code>send</code> 메소드는 우리가 보게 되는
메세지를 저장하기 위해 <code>sent_message</code>를 수정할 수 있을 것입니다. Listing
15-22는 이것이 어떤 형태인지를 보여줍니다: </p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">        limit_tracker.set_value(75);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 15-22: <code>RefCell&lt;T&gt;</code>를 사용하여 바깥쪽에서는
불변으로 간주되는 동안 내부의 값을 변경하기</span></p>
<p><code>sent_messages</code> 필드는 이제 <code>Vec&lt;String&gt;</code> 대신 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
타입입니다. <code>new</code> 함수 내에서, 우리는 빈 벡터를 감싼 새로운 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
인스턴스를 생성합니다.</p>
<p><code>send</code> 메소드의 구현부에 대하여, 첫번째 파라미터는 여전히 <code>self</code>의 불변
빌림 형태인데, 이는 트레잇의 정의와 일치합니다. 우리는 <code>self.sent_messages</code>
내의 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 상에 있는 <code>borrow_mut</code>를 호출하여
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 내의 값에 대한 가변 참조자를 얻는데, 이는
벡터입니다. 그런 다음에는 그 벡터에 대한 가변 참조자 상의 <code>push</code>를 호출하여
테스트하는 동안 보내진 메세지를 추적할 수 있습니다.</p>
<p>마지막으로 우리가 변경한 부분은 단언 부분 내에 있습니다: 내부 벡터 내에
몇개의 아이템이 있는지 보기 위해서, 우리는 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 상의
<code>borrow</code>를 호출하여 벡터에 대한 불변 참조자를 얻습니다.</p>
<p>이제 여러분이 <code>RefCell&lt;T&gt;</code>를 어떻게 사용하는지 보았으니, 이것이 어떤 식으로 동작하는지 파고 들어 봅시다! </p>
<h4 id="refcellt는-런타임에-빌림을-추적합니다"><a class="header" href="#refcellt는-런타임에-빌림을-추적합니다"><code>RefCell&lt;T&gt;</code>는 런타임에 빌림을 추적합니다</a></h4>
<p>불변 및 가변 참조자를 만들때, 우리는 각각 <code>&amp;</code> 및 <code>&amp;mut</code> 문법을 사용합니다.
<code>RefCell&lt;T&gt;</code>을 이용할때는 <code>borrow</code>와 <code>borrow_mut</code> 메소드를 사용하는데,
이들은 <code>RefCell&lt;T&gt;</code>가 소유한 안전한 API 중 일부입니다. <code>borrow</code> 메소드는
스마트 포인터 타입인 <code>Ref&lt;T&gt;</code>를 반환하고, <code>borrow_mut</code>는 스마트 포인터
타입 <code>RefMut&lt;T&gt;</code>을 반환합니다. 두 타입 모두 <code>Deref</code>를 구현하였으므로
우리는 이들을 보통의 참조자처럼 다룰 수 있습니다.</p>
<p><code>RefCell&lt;T&gt;</code>는 현재 활성화된 <code>Ref&lt;T&gt;</code>와 <code>RefMut&lt;T&gt;</code> 스마트 포인터들이
몇개나 있는지 추적합니다. 우리가 <code>borrow</code>를 호출할 때마다, <code>RefCell&lt;T&gt;</code>는
불변 참조자가 활성화된 갯수를 증가시킵니다. <code>Ref&lt;T&gt;</code> 값이 스코프 밖으로 벗어날
때, 불변 빌림의 갯수는 하나 감소합니다. 컴파일 타임에서의 빌림 규칙과 똑같이,
<code>RefCell&lt;T&gt;</code>는 우리가 어떤 시점에서든 여러 개의 불변 빌림 혹은 하나의 가변
빌림을 가질 수 있도록 합니다.</p>
<p>만일 이 규칙들을 위반한다면, <code>RefCell&lt;T&gt;</code>의 구현체는 우리가 참조자들을
가지고 했을 때처럼 컴파일 에러를 내기 보다는 런타임에 <code>panic!</code>을 일으킬
것입니다. Listing 15-23은 Listing 15-22의 <code>send</code> 구현의 수정을
보여줍니다. 우리는 <code>RefCell&lt;T&gt;</code>가 런타임에 두개의 활성화된 가변 빌림을
같은 스코프에 만드는 일을 하는 것을 막아주는 것을 보여주기 위해서 의도적으로
그런 시도를 하는 중입니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}</code></pre>
<p><span class="caption">Listing 15-23: <code>RefCell&lt;T&gt;</code>이 패닉을 일으킬
것을 보기 위한 같은 스코프 내에 두 개의 가변 참조자 만들기</span></p>
<p>우리는 <code>borrow_mut</code>로부터 반환된 <code>RefMut&lt;T&gt;</code> 스마트 포인터를 위한 <code>one_borrow</code>
변수를 만들었습니다. 그런 다음 또다른 가변 빌림을 같은 방식으로 <code>two_borrow</code> 변수에
만들어 넣었습니다. 이는 같은 스코프에 두개의 가변 참조자를 만드는데, 이는 허용되지
않습니다. 우리가 우리의 라이브러리를 위한 테스트를 실행할 때, Listing 15-23의
코드는 어떠한 에러 없이 컴파일될 것이지만, 테스트는 실패할 것입니다:</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
    'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>코드가 <code>already borrowed: BorrowMutError</code>라는 메세지와 함께 패닉을
일으켰음을 주목하세요. 이것이 바로 <code>RefCell&lt;T&gt;</code>가 런타임에 빌림 규칙의 위반을
다루는 방법입니다.</p>
<p>빌림 에러를 컴파일 타임보다 런타임에 잡는다는 것은 개발 과정 이후에 우리
코드의 실수를 발견할 것이란 의미이고, 심지어는 우리 코드가 프로덕션으로
배포될 때 까지도 발견되지 않을 가능성도 있습니다. 또한, 우리 코드는
컴파일 타임 대신 런타임에 빌림을 추적하는 결과로서 약간의 런타임 성능
페널티를 초래할 것입니다. 그러나, <code>RefCell&lt;T&gt;</code>를 이용하는 것은
우리가 오직 불변 값만 허용하는 콘텍스트 내에서 그것이 본 메세지를 추적하기
위해서 스스로를 변경할 수 있는 목 객체를 작성하도록 해줍니다. 우리는 일반적인
참조자가 우리에게 제공하는 것보다 더 많은 기능을 얻기 위해서 트레이드 오프에도
불구하고 <code>RefCell&lt;T&gt;</code>를 이용할 수 있습니다.</p>
<h3 id="rct와-refcellt를-조합하여-가변-데이터의-복수-소유자-만들기"><a class="header" href="#rct와-refcellt를-조합하여-가변-데이터의-복수-소유자-만들기"><code>Rc&lt;T&gt;</code>와 <code>RefCell&lt;T&gt;</code>를 조합하여 가변 데이터의 복수 소유자 만들기</a></h3>
<p><code>RefCell&lt;T&gt;</code>를 사용하는 일반적인 방법은 <code>Rc&lt;T&gt;</code>와 함께 조합하는 것입니다. <code>Rc&lt;T&gt;</code>이
어떤 데이터에 대해 복수의 소유자를 허용하지만, 그 데이터에 대한 불변 접근만 제공하는 것을
상기하세요. 만일 우리가 <code>RefCell&lt;T&gt;</code>을 들고 있는 <code>Rc&lt;T&gt;</code>를 갖는다면, 우리가 변경
가능<em>하면서</em> 복수의 소유자를 갖는 값을 가질 수 있습니다!</p>
<p>예를 들면, Listing 15-18에서 우리가 어떤 리스트의 소유권을 공유하는 여러 개의
리스트를 가질 수 있도록 하기 위해 <code>Rc&lt;T&gt;</code>를 사용했던 cons 리스트 예제를 상기해보세요.
<code>Rc&lt;T&gt;</code>가 오직 불변의 값만을 가질 수 있기 때문에, 우리가 이들을 일단 만들면 리스트
안의 값들을 변경하는 것은 불가능했습니다. 이 리스트 안의 값을 변경하는 능력을 얻기
위해서 <code>RefCell&lt;T&gt;</code>을 추가해 봅시다. Listing 15-24는 <code>Cons</code> 정의 내에
<code>RefCell&lt;T&gt;</code>를 사용함으로써 우리가 모든 리스트 내에 저장된 값을 변경할 수 있음을
보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}</code></pre></pre>
<p><span class="caption">Listing 15-24: <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>을 사용하여
변경 가능한 <code>List</code> 생성하기</span></p>
<p>우리는 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>의 인스턴스인 값을 생성하고 <code>value</code>라는 이름의
변수 안에 이를 저장하여 나중에 이를 직접 접근할 수 있게 했습니다. 그런 다음
우리는 <code>value</code>를 가지고 있는 <code>Cons</code> variant와 함께 <code>a</code>에다 <code>List</code>를
생성하였습니다. <code>value</code>에서 <code>a</code>로 소유권이 이전되거나 <code>value</code>로부터 빌린
<code>a</code> 보다는 <code>a</code>와 <code>value</code> 둘다 내부의 <code>5</code> 값에 대한 소유권을 얻기 위해서는
<code>value</code>를 클론할 필요가 있습니다.</p>
<p>리스트 <code>a</code>는 <code>Rc&lt;T&gt;</code>로 감싸져서 우리가 <code>b</code>와 <code>c</code> 리스트를 만들때, 이 리스트들은
둘다 <code>a</code>를 참조할 수 있는데, 이는 Listing 15-18에서 해본 것입니다.</p>
<p><code>a</code>, <code>b</code>, 그리고 <code>c</code> 리스트를 생성한 이후, 우리는 <code>value</code> 내의 값에 10을
더했습니다. <code>value</code> 상의 <code>borrow_mut</code>를 호출함으로써 수행되었는데, 이는
내부의 <code>RefCell&lt;T&gt;</code>값을 가리키는 <code>Rc&lt;T&gt;</code>를 역참조하기 위해서 우리가 5장에서
논의했던 자동 역참조 기능을 사용한 것입니다 (“<code>-&gt;</code> 연산자는 어디로 갔나요?”절을 보세요).
<code>borrow_mut</code> 메소드는 <code>RefMut&lt;T&gt;</code> 스마트 포인터를 반환하고, 우리는 여기에 역참조
연산자를 사용한 다음 내부 값을 변경합니다.</p>
<p><code>a</code>, <code>b</code>, 그리고 <code>c</code>를 출력할때, 우리는 이 리스트들이 모두 5가 아니라 변경된
값 15를 가지고 있는 것을 볼 수 있습니다:</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>이 기술은 매우 깔끔합니다! <code>RefCell&lt;T&gt;</code>을 이용함으로써, 우리는 표면상으로는
불변인 <code>List</code>를 갖고 있습니다. 하지만 우리는 내부 가변성 접근을 제공하여
우리가 원할때 데이터를 변경시킬 수 있는 <code>RefCell&lt;T&gt;</code> 내의 메소드를 사용할
수 있습니다. 빌림 규칙의 런타임 검사는 데이터 레이스로부터 우리를 지켜주고, 우리
데이터 구조의 이러한 유연성을 위해서 약간의 속도를 맞거래하는 것이 때때로
가치있습니다.</p>
<p>표준 라이브러리는 내부 가변성을 제공하는 다른 타입을 가지고 있는데, 이를 테면
<code>Cell&lt;T&gt;</code>는 내부 값의 참조자를 주는 대신 값이 복사되어 <code>Cell&lt;T&gt;</code> 밖으로
나오는 점만 제외하면 비슷합니다. 또한 <code>Mutex&lt;T&gt;</code>가 있는데, 이는 스레드들을
건너가며 사용해도 안전한 내부 가변성을 제공합니다; 이것의 사용법은 16장에서
다룰 것입니다. 이 타입들의 차이점에 대해 더 자세히 알고 싶다면 표준 라이브러리
문서를 참조하세요.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
