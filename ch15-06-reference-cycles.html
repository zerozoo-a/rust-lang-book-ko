<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입들</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수 동작 원리</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 이용해 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install을 이용해 Crates.io에서 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 Cargo 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운팅 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html" class="active"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메세지 패싱</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 확장 가능한 동시성: Sync와 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법의 모든 것</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 고급 라이프타임</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 고급 트레잇</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 고급 함수와 클로저</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자 및 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - derive 가능한 트레잇</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 매크로</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 본 책의 번역본 목록</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 새로운 기능</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-glossary.html"><strong aria-hidden="true">21.8.</strong> H - 번역 용어 정리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="순환-참조는-메모리-릭을-발생시킬-수-있습니다"><a class="header" href="#순환-참조는-메모리-릭을-발생시킬-수-있습니다">순환 참조는 메모리 릭을 발생시킬 수 있습니다</a></h2>
<p>러스트의 메모리 안정성 보장은 (<em>메모리 릭 (memory leak)</em> 이라고도 알려져 있는) 뜻하지
않게 해제되지 않는 메모리를 생성하기 힘들게 하지만, 그게 불가능한 것은 아닙니다.
메모리 릭을 완전히 방지하는 것은 컴파일 타임에 데이터 레이스를 허용하지 않는 것과 마찬가지로
러스트가 보장하는 것들 중 하나가 아닌데, 이는 메모리 릭도 러스트에서는 메모리 안정성에 포함됨을
의미합니다. 러스트가 <code>Rc&lt;T&gt;</code> 및 <code>RefCell&lt;T&gt;</code>를 사용하여 메모리 릭을 허용하는 것을 우리는
알 수 있습니다: 즉 아이템들이 서로를 순환 참조하는 참조자를 만드는 것이 가능합니다. 이는
메모리 릭을 발생시키는데, 그 이유는 순환 고리 안의 각 아이템들의 참조 카운트는 결코 0이
되지 않을 것이고, 그러므로 값들은 버려지지 않을 것이기 때문입니다.</p>
<h3 id="순환-참조-만들기"><a class="header" href="#순환-참조-만들기">순환 참조 만들기</a></h3>
<p>Listing 15-25의 <code>List</code> 열거형과 <code>tail</code> 메소드 정의를 가지고서
어떻게 순환 참조가 생길 수 있고, 이를 어떻게 방지하는지
알아봅시다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}</code></pre></pre>
<p><span class="caption">Listing 15-25: <code>RefCell&lt;T&gt;</code>를 가지고 있어서
<code>Cons</code> variant가 참조하는 것을 변경할 수 있는 cons 리스트 정의</span></p>
<p>우리는 Listing 15-5의 <code>List</code> 정의의 또다른 변형을 이용하고 있습니다.
이제 <code>Cons</code> variant 내의 두번째 요소는 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>인데,
이는 Listing 15-24에서 우리가 했던 것처럼 <code>i32</code> 값을 변경하는 능력을
갖는 대신, <code>Cons</code> variant가 가리키고 있는 <code>List</code> 값을 변경하길 원한다는
의미입니다. 또한 <code>Cons</code> variant를 갖고 있다면 두번째 아이템에 접근하기
편하도록 <code>tail</code> 메소드를 추가하고 있습니다.</p>
<p>Listing 15-26에서 우리는 Listing 15-25의 정의를 사용하는 <code>main</code> 함수를
추가하고 있습니다. 이 코드는 <code>a</code>에 리스트를 만들고 <code>b</code>에는 <code>a</code>의 리스트를 가리키고
있는 리스트를 만들어 넣었습니다. 그 다음 <code>a</code>의 리스트가 <code>b</code>를 가리키도록 수정하는데,
이것이 순환 참조를 생성합니다. 이 과정 내의 다양한 지점에서 참조 카운트가 얼마인지를
보기 위해 곳곳에 <code>println!</code> 구문들이 있습니다.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match *self {
</span><span class="boring">            Cons(_, ref item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}</code></pre></pre>
<p><span class="caption">Listing 15-26: 두 개의 <code>List</code> 값이 서로를 가리키는
순환 참조 생성하기</span></p>
<p>우리는 초기값 리스트 <code>5, Nil</code>를 가진 <code>List</code> 값을 갖는 <code>Rc&lt;List&gt;</code>
인스턴스를 만들어 <code>a</code> 변수에 넣었습니다. 그런 다음 값 10과 <code>a</code>의 리스트를
가리키는 또다른 <code>List</code> 값을 갖는 <code>Rc&lt;List&gt;</code> 인스턴스를 만들어서 <code>b</code>
변수에 넣었습니다.</p>
<p>우리는 <code>a</code>를 수정하여 이것이 <code>Nil</code> 대신 <code>b</code>를 가리키도록 하였습니다. <code>a</code> 내의
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>에 대한 참조자를 얻어오기 위해 <code>tail</code> 메소드를 사용했는데,
이 참조자는 <code>link</code> 변수에 집어넣습니다. 그런 다음 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>의
<code>borrow_mut</code> 메소드를 사용하여 <code>Nil</code> 값을 가지고 있는<code>Rc&lt;List&gt;</code> 내부의 값을
<code>b</code>의 <code>Rc&lt;List&gt;</code>로 바꾸었습니다.</p>
<p>지금 잠깐동안 마지막 <code>println!</code> 문이 들어가지 않도록 주석처리하고 이 코드를 실행시킬
때, 아래와 같은 출력을 얻을 것입니다:</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p><code>a</code>의 리스트가 <code>b</code>를 가리키도록 변경한 이후 <code>a</code>와 <code>b</code>의 <code>Rc&lt;List&gt;</code>
인스턴스의 참조 카운트는 둘 다 2입니다. <code>main</code>의 끝에서, 러스트는
<code>b</code>를 먼저 버리는 시도를 할 것인데, 이는 <code>a</code>와 <code>b</code>의 각각의 <code>Rc&lt;List&gt;</code>
인스턴스 내의 카운트를 1로 줄일 것입니다.</p>
<p>하지만 <code>a</code>가 여전히 <code>b</code> 내에 있는 <code>Rc&lt;List&gt;</code>를 참조하는 상태기 때문에, 이
<code>Rc&lt;List&gt;</code>는 0이 아니라 1의 카운트를 갖게 되고, 따라서 <code>Rc&lt;List&gt;</code>가 힙에
가지고 있는 메모리는 버려지지 않을 것입니다. 그 메모리는 참조 카운트 1을 가진 채로
영원히 그 자리에 그냥 있을 것입니다. 이러한 순환 참조를 시각화하기 위해 Figure
15-4의 다이어그램을 만들었습니다.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: 리스트 <code>a</code>와 <code>b</code>가 서로를 가리키고
있는 순환 참조</span></p>
<p>만일 여러분이 마지막 <code>println!</code>의 주석을 해제하고 프로그램을 실행해보면, 러스트는
<code>a</code>를 가리키고 있는 <code>b</code>를 가리키고 있는 <code>a</code>를 가리키고 있는... 과 같은 식으로
스택 오버플로우가 날 때까지 이 순환을 출력하려 할 것입니다.</p>
<p>이 경우, 우리가 순환 참조를 만든 직후, 프로그램은 종료됩니다. 위의 순환의
결과는 그렇게까지 심각하지는 않습니다. 하지만, 만일 좀더 복잡한 프로그램이
많은 매모리를 순환 형태로 할당했고 오랫동안 이를 유지했더라면, 프로그램은 
필요한 것보다 더 많은 메모리를 사용하게 되고, 사용 가능한 메모리를 동나게
하여 시스템을 멈추게 했을런지도 모릅니다.</p>
<p>순환 참조를 만드는 것은 쉽게 이루어지지는 않지만, 불가능한 것도 아닙니다.
만일 여러분이 <code>Rc&lt;T&gt;</code> 값을 가지고 있는 <code>RefCell&lt;T&gt;</code> 혹은 내부 가변성
및 참조 카운팅 기능이 있는 타입들로 유사한 조합을 사용한다면, 여러분은 순환을
만들지 않음을 보장해야 합니다; 이 순환들을 찾아내는 것을 러스트에 의지할 수는
없습니다. 순환 참조를 만드는 것은 여러분이 자동화된 테스트, 코드 리뷰, 그 외
소프트웨어 개발 연습 등을 이용하여 최소화해야 할 프로그램 내의 논리적
버그입니다.</p>
<p>순환 참조를 피하는 또다른 해결책은 여러분의 데이터 구조를 재구성하여
어떤 참조자는 소유권을 갖고 어떤 참조자는 그렇지 않도록 하는 것입니다.
결과적으로 여러분은 몇 개의 소유권 관계와 몇 개의 소유권 없는 관계로
이루어진 순환을 가질 수 있으며, 소유권 관계들만이 값을 버릴지 말지에
관해 영향을 주게 됩니다. Listing 15-25에서 우리는 <code>Cons</code> variant가
언제나 리스트를 소유하기를 원하므로, 데이터 구조를 재구성하는 것은 불가능합니다.
언제 소유권 없는 관계가 순환 참조를 방지하는 적절한 방법이 되는 때인지를
알기 위해서 부모 노드와 자식 노드로 구성된 그래프를 이용하는 예제를
살펴봅시다.</p>
<h3 id="참조-순환-방지하기-rct를-weakt로-바꾸기"><a class="header" href="#참조-순환-방지하기-rct를-weakt로-바꾸기">참조 순환 방지하기: <code>Rc&lt;T&gt;</code>를 <code>Weak&lt;T&gt;</code>로 바꾸기</a></h3>
<p>이제까지 우리는 <code>Rc::clone</code>을 호출하는 것이 <code>Rc&lt;T&gt;</code> 인스턴스의 <code>strong_count</code>를
증가시키고, <code>Rc&lt;T&gt;</code> 인스턴스는 이것의 <code>strong_count</code>가 0이 된 경우에만 제거되는
것을 보았습니다. 여러분은 또한 <code>Rc::downgrade</code>를 호출하고 여기에 <code>Rc&lt;T&gt;</code>에 대한
참조자를 넘겨서 <code>Rc&lt;T&gt;</code> 인스턴스 내의 값을 가리키는 <em>약한 참조 (weak reference)</em>
를 만들 수 있습니다. 여러분이 <code>Rc::downgrade</code>를 호출하면, 여러분은 <code>Weak&lt;T&gt;</code> 타입의
스마트 포인터를 얻게 됩니다. <code>Rc&lt;T&gt;</code> 인스턴스의 <code>strong_count</code>를 1 증가시키는 대신,
<code>Rc::downgrade</code>는 <code>weak_count</code>를 1 증가시킵니다. <code>Rc&lt;T&gt;</code> 타입은 몇 개의
<code>Weak&lt;T&gt;</code> 참조가 있는지 추적하기 위해서 <code>strong_count</code>와 유사한 방식으로
<code>weak_count</code>를 사용합니다. 차이점은 <code>Rc&lt;T&gt;</code>인스턴스가 제거되기 위해서 <code>weak_count</code>가 
0일 필요는 없다는 것입니다.</p>
<p>강한 참조는 여러분이 <code>Rc&lt;T&gt;</code> 인스턴스의 소유권을 공유할 수 있는 방법입니다. 약한
참조는 소유권 관계를 표현하지 않습니다. 이것은 순환 참조를 야기하지 않는데 그 이유는
몇몇의 약한 참조를 포함하는 순환이라도 강한 참조의 카운트가 0이 되고 나면 깨지게
될 것이기 때문입니다.</p>
<p><code>Weak&lt;T&gt;</code>가 참조하고 있는 값이 이미 버려졌을지도 모르기 때문에, <code>Weak&lt;T&gt;</code>가
가리키고 있는 값을 가지고 어떤 일을 하기 위해서는 그 값이 여전히 존재하는지를 반드시
확인해야 합니다. 이를 위해 <code>Weak&lt;T&gt;</code>의 <code>upgrade</code> 메소드를 호출하는데, 이 메소드는
<code>Option&lt;Rc&lt;T&gt;&gt;</code>를 반환할 것입니다. 만일 <code>Rc&lt;T&gt;</code> 값이 아직 버려지지 않았다면
여러분은 <code>Some</code> 결과를 얻게 될 것이고 <code>Rc&lt;T&gt;</code> 값이 버려졌다면 <code>None</code> 결과값을
얻게 될 것입니다. <code>upgrade</code>가 <code>Option&lt;T&gt;</code>를 반환하기 때문에, 러스트는 <code>Some</code>의
경우와 <code>None</code>의 경우가 반드시 처리되도록 할 것이고, 따라서 유효하지 않은 포인터는
없을 것입니다.</p>
<p>예제로서 어떤 아이템이 오직 다음 아이템에 대해서만 알고 있는 리스트를 이용하는
것보다는 자식 아이템 <em>그리고</em> 부모 아이템에 대해 모두 알고 있는 아이템을 갖는
트리를 만들어 보겠습니다.</p>
<h4 id="트리-데이터-구조-만들기-자식-노드를-가진-node"><a class="header" href="#트리-데이터-구조-만들기-자식-노드를-가진-node">트리 데이터 구조 만들기: 자식 노드를 가진 <code>Node</code></a></h4>
<p>자신의 자식 노드에 대해 알고 있는 노드를 갖는 트리를 만드는 것으로 시작해 보겠습니다.
우리는 <code>i32</code>값은 물론 자식 <code>Node</code>들의 참조자들 또한 가지고 있는 <code>Node</code>라는 이름의
구조체를 만들 것입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>우리는 <code>Node</code>가 자신의 자식들을 소유하기를 원하고, 이 소유권을 공유하여 트리의 각
<code>Node</code>에 직접 접근할 수 있도록 하기를 원합니다. 이를 하기 위해서 <code>Vec&lt;T&gt;</code> 아이템이
<code>Rc&lt;Node&gt;</code> 타입의 값이 되도록 정의하였습니다. 또한 우리는 어떤 노드가 다른 노드의
자식이 되도록 수정하기를 원하므로, <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>를 <code>RefCell&lt;T&gt;</code>로 감싼
<code>children</code>을 갖도록 하였습니다.</p>
<p>그 다음, Listing 15-27에서 보시는 것처럼 이 구조체 정의를 이용하여 3의 값과
자식 노드가 없는 <code>leaf</code>라는 이름의 <code>Node</code> 인스턴스, 그리고 5의 값과 <code>leaf</code>를
자식으로 갖는 <code>branch</code>라는 이름의 인스턴스를 만들도록 하겠습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">   children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">Listing 15-27: 자식이 없는 <code>leaf</code> 노드와
이 <code>leaf</code>를 자식 중 하나로 갖는 <code>branch</code> 노드 만들기</span></p>
<p><code>leaf</code> 내의 <code>Rc&lt;Node&gt;</code>를 클론하여 이를 <code>branch</code> 내에 저장했는데, 이는 <code>leaf</code> 내의
<code>Node</code>가 이제 두 소유권자를 가지게 되었다는 의미입니다. 우리는 <code>branch.children</code>를
통하여 <code>branch</code>에서부터 <code>leaf</code>까지 접근할 수 있게 되었지만, <code>leaf</code>에서부터 <code>branch</code>로
접근할 방법은 없습니다. 그 이유는 <code>leaf</code>가 <code>branch</code>에 대한 참조자를 가지고 있지 않아서
이들간의 연관성을 알지 못하기 때문입니다. 우리는 <code>leaf</code>로 하여금 <code>branch</code>가 그의
부모임을 알도록 하기를 원합니다. 이걸 다음에 해보겠습니다.</p>
<h4 id="자식으로부터-부모로-가는-참조자-추가하기"><a class="header" href="#자식으로부터-부모로-가는-참조자-추가하기">자식으로부터 부모로 가는 참조자 추가하기</a></h4>
<p>자식 노드가 그의 부모를 알도록 만들기 위하여, <code>parent</code> 필드를 우리의 <code>Node</code> 구조체
정의에 추가할 필요가 있습니다. 문제는 <code>parent</code>의 타입이 어떤 것이 되어야 하는지를 결정하는
중에 발생합니다. 이것이 <code>Rc&lt;T&gt;</code>를 담을 수 없음을 우리는 알고 있는데, 그렇게 하게 되면
<code>branch</code>를 가리키고 있는 <code>leaf.parent</code>와 <code>leaf</code>를 가리키고 있는 <code>branch.children</code>을
가지고 있는 순환 참조를 만들게 되며, 이것들의 <code>strong_count</code>값을 결코 0이 안되도록 하는
일을 야기하기 때문입니다.</p>
<p>이 관계들을 다른 방식으로 생각해보면, 부모 노드는 그의 자식들을 소유해야 합니다:
만일 부모 노드가 버려지게 되면, 그의 자식 노드들도 또한 버려져야 합니다. 하지만,
자식은 그의 부모를 소유해서는 안됩니다: 만일 우리가 자식 노드를 버리면, 그 부모는
여전히 존재해야 합니다. 이것이 바로 약한 참조를 위한 경우에 해당됩니다!</p>
<p>따라서 <code>Rc&lt;T&gt;</code> 대신 <code>Weak&lt;T&gt;</code>를 이용하여, 특별히 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>를
이용하여 <code>parent</code>의 타입을 만들겠습니다. 이제 우리의 <code>Node</code> 구조체 정의는 아래와
같이 생기게 되었습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>노드는 그의 부모 노드를 참조할 수 있게 되겠지만 그 부모를 소유하지는 않습니다.
Listing 15-28에서, 우리는 이 새로운 정의를 사용하도록 <code>main</code>을 업데이트하여
<code>leaf</code> 노드가 그의 부모인 <code>branch</code>를 참조할 수 있는 방법을 갖도록 할 것입니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">Listing 15-28: 부모 노드 <code>branch</code>의 약한 참조를
갖는 <code>leaf</code> 노드</span></p>
<p><code>leaf</code> 노드를 만드는 것은 <code>parent</code> 필드를 제외하고는 Listing 15-27에서 <code>leaf</code>
노드를 만드는 방법과 비슷해 보입니다: <code>leaf</code>는 부모없이 시작되어서, 새로운 비어있는
<code>Weak&lt;Node&gt;</code> 참조자 인스턴스를 생성하였습니다.</p>
<p>이 시점에서, 우리가 <code>upgrade</code> 메소드를 사용하여 <code>leaf</code>의 부모에 대한 참조자를
얻는 시도를 했을 때, 우리는 <code>None</code> 값을 얻습니다. 첫번째 <code>println!</code> 구문에서는
아래와 같은 출력을 보게됩니다:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p><code>branch</code> 노드를 생성할 때, 이 또한 <code>parent</code> 필드에 새로운 <code>Weak&lt;Node&gt;</code>
참조자를 가지도록 하는데, 이는 <code>branch</code>가 부모 노드를 가지지 않기 때문입니다.
우리는 여전히 <code>leaf</code>를 <code>branch</code>의 자식 중 하나로서 가지게 됩니다. 일단
<code>branch</code> 내의 <code>Node</code> 인스턴스를 가지게 되면, <code>leaf</code>에게 그의 부모에 대한
<code>Weak&lt;Node&gt;</code> 참조자를 가지도록 수정할 수 있습니다. 우리는 <code>leaf</code>의 <code>parent</code>
필드 내의 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> 상의 <code>borrow_mut</code> 메소드를 사용하고,
그런 다음 <code>Rc::downgrade</code> 함수를 이용하여 <code>branch</code>의 <code>Rc&lt;Node&gt;</code>로부터
<code>branch</code>에 대한 <code>Weak&lt;Node&gt;</code> 참조자를 생성하였습니다.</p>
<p><code>leaf</code>의 부모를 다시한번 출력할 때, 이번에는 <code>branch</code>를 가지고 있는 <code>Some</code> variant를
얻게될 것입니다: 이제 <code>leaf</code>는 그의 부모에 접근할 수 있습니다! <code>leaf</code>를 출력할 때, 우리는
또한 Listing 15-26에서 발생했던 것과 같이 궁극적으로 스택 오버플로우로 끝나버리는 순환을
피하게 되었습니다; <code>Weak&lt;Node&gt;</code> 참조자는 <code>(Weak)</code>로 출력됩니다:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>무한 출력이 없다는 것은 이 코드가 순환 참조를 생성하지 않는 것을 나타냅니다.
이것은 또한 <code>Rc::strong_count</code>와 <code>Rc::weak_count</code>를 호출함으로써
얻은 값을 살펴보는 것으로도 알 수 있습니다.</p>
<h4 id="strong_count와-weak_count의-변화를-시각화하기"><a class="header" href="#strong_count와-weak_count의-변화를-시각화하기"><code>strong_count</code>와 <code>weak_count</code>의 변화를 시각화하기</a></h4>
<p>새로운 내부 스코프를 만들고 <code>branch</code>의 생성을 이 스코프로 옮기는 것으로
<code>Rc&lt;Node&gt;</code> 인스턴스의 <code>strong_count</code>와 <code>weak_count</code> 값이 어떻게
변하는지 살펴보기로 합시다. 그렇게 함으로써, 우리는 <code>branch</code>가 만들어질 때와
그 다음 스코프 밖으로 벗어났을 때 어떤일이 생기는지 알 수 있습니다. 수정본은
Listing 15-29와 같습니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">Listing 15-29: <code>branch</code>를 내부 스코프에서 만들고
강한 참조 및 약한 참조 카운트를 시험하기</span></p>
<p><code>leaf</code>가 생성된 다음, 이것의 <code>Rc&lt;Node&gt;</code>는 강한 참조 카운트 1개와 약한 참조 카운트
0개를 갖습니다. 내부 스코프에서 <code>branch</code>를 만들고 <code>leaf</code>와 연관짓게 되는데, 이때
우리가 카운트를 출력하면 <code>branch</code>의 <code>Rc&lt;Node&gt;</code>는 강한 참조 카운트 1개와
(<code>Weak&lt;Node</code>를 가지고 <code>branch</code>를 가리키는 <code>leaf.parent</code>에 대한) 약한 참조 카운트
1개를 갖고 있을 것입니다. 이제 <code>branch</code>가 <code>leaf</code>의 <code>Rc&lt;Node&gt;</code> 클론을
<code>branch.children</code>에 저장해 두었으므로, <code>leaf</code>의 카운트를 출력해보면
강한 참조 카운트는 2개가 되지만, 약한 참조 카운트는 여전히
0개일 것입니다.</p>
<p>내부 스코프가 끝나게 되면, <code>branch</code>는 스코프 밖으로 벗어나게 되며 <code>Rc&lt;Node&gt;</code>의
강한 참조 카운트는 0으로 줄어들게 되므로, 이것의 <code>Node</code>는 버려지게 됩니다.
<code>leaf.parent</code>로부터 발생된 1개의 약한 참조 카운트는 <code>Node</code>가 버려질지 말지에
대한 어떠한 영향도 주지 않으므로, 아무런 메모리 릭도 발생하지 않았습니다!</p>
<p>만일 우리가 이 스코프의 끝 이후에 <code>leaf</code>의 부모에 접근하기를 시도한다면, 우리는
다시 <code>None</code>을 얻게 될 것입니다. 프로그램의 끝 부분에서, <code>leaf</code>의 <code>Rc&lt;Node&gt;</code>는
강한 참조 카운트 1개와 약한 참조 카운트 0개를 갖고 있는데, 그 이유는 <code>leaf</code> 변수가
이제 다시 <code>Rc&lt;Node&gt;</code>에 대한 유일한 참조자이기 때문입니다.</p>
<p>참조 카운트들과 버리는 값들을 관리하는 모든 로직은 <code>Rc&lt;T&gt;</code>와
<code>Weak&lt;T&gt;</code>, 그리고 이들의 <code>Drop</code> 트레잇에 대한 구현부에 만들어져
있습니다. 자식으로부터 부모로의 관계가 <code>Node</code>의 정의 내에서
<code>Weak&lt;T&gt;</code> 참조자로 되어야 함을 특정함으로서, 여러분은 순환 참조와
메모리 릭을 만들지 않고도 자식 노드를 가리키는 부모 노드 혹은 그 반대의
것을 가지게 될 수 있습니다.</p>
<h2 id="정리"><a class="header" href="#정리">정리</a></h2>
<p>이번 장에서는 러스트가 일반적인 참조자를 가지고 기본적으로 보장하는 것들과는
다른 보장 및 트레이드 오프를 만들어내기 위해 스마트 포인터를 사용하는 방법을
다루었습니다. <code>Box&lt;T&gt;</code> 타입은 알려진 크기를 갖고 있고 힙에 할당된 데이터를
가리킵니다. <code>Rc&lt;T&gt;</code> 타입은 힙에 있는 데이터에 대한 참조자의 개수를 추적하여
그 데이터가 여러 개의 소유자들을 가질 수 있도록 합니다. 내부 가변성을 갖춘
<code>RefCell&lt;T&gt;</code> 타입은 불변 타입을 원하지만 그 타입의 내부 값을 변경하기를
원할 때 사용할 수 있는 타입을 제공합니다; 이는 또한 컴파일 타임 대신 런타임에
빌림 규칙을 따르도록 강제합니다.</p>
<p>또한 <code>Deref</code> 및 <code>Drop</code> 트레잇을 다루었는데, 이는 스마트 포인터의 수많은
기능을 활성화해줍니다. 우리는 메모리 릭을 발생시킬 수 있는 순환 참조에 대한
것과 <code>Weak&lt;T&gt;</code>을 이용하여 이들을 방지하는 방법도 탐구하였습니다.</p>
<p>만일 이번 장이 여러분의 흥미를 언짢게 하고 여러분이 직접 여러분만의 스마트
포인터를 구현하기를 원한다면, <a href="https://doc.rust-lang.org/stable/nomicon/">“러스토노미콘”</a>에서 더 유용한
정보를 확인하세요.</p>
<p>다음으로 우리는 러스트의 동시성에 대해 이야기해볼 것입니다. 여러분은 심지어 몇 개의
새로운 스마트 포인터에 대해서도 배우게 될 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch16-00-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-05-interior-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch16-00-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
