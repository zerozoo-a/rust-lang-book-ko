<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>mod와 파일 시스템 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입들</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수 동작 원리</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html" class="active"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 이용해 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install을 이용해 Crates.io에서 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 Cargo 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운팅 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메세지 패싱</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 확장 가능한 동시성: Sync와 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법의 모든 것</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 고급 라이프타임</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 고급 트레잇</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 고급 함수와 클로저</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자 및 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - derive 가능한 트레잇</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 매크로</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 본 책의 번역본 목록</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 새로운 기능</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-glossary.html"><strong aria-hidden="true">21.8.</strong> H - 번역 용어 정리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="mod와-파일-시스템"><a class="header" href="#mod와-파일-시스템"><code>mod</code>와 파일 시스템</a></h2>
<p>먼저 카고를 이용해서 새로운 프로젝트를 만드는 것으로 모듈 예제를 시작하려고 하는데,
바이너리 크레이트(crate)을 만드는 대신에 라이브러리 크레이트을 만들 것입니다. 여기서
라이브러리 크레이트이란 다른 사람들이 자신들의 프로젝트에 디펜던시(dependency)로 추가할
수 있는 프로젝트를 말합니다. 예를 들어, 2장의 <code>rand</code> 크레이트은 우리가 추리 게임
프로젝트에서 디펜던시로 사용했던 라이브러리 크레이트입니다.</p>
<p>우리는 몇가지 일반적인 네트워크 기능을 제공하는 라이브러리의 뼈대를 만들 것입니다;
여기서는 모듈들과 함수들의 조직화에 집중할 것이고, 함수의 본체에 어떤 코드가 들어가야
하는지는 신경쓰지 않겠습니다. 이 라이브러리를 <code>communicator</code>라고 부르겠습니다.
라이브러리를 만들기 위해서는 <code>--bin</code> 대신 <code>--lib</code> 옵션을 넘기세요:</p>
<pre><code class="language-text">$ cargo new communicator --lib
$ cd communicator
</code></pre>
<p>카고가 <em>src/main.rs</em> 대신 <em>src/lib.rs</em>을 생성했음을 주목하세요. <em>src/lib.rs</em>
내부를 보면 다음과 같은 코드를 찾을 수 있습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
<span class="boring">}</span></code></pre></pre>
<p>카고는 우리가 만든 라이브러리의 작성 시작을 돕기 위해 빈 테스트를 만드는데,
이는 <code>--bin</code> 옵션을 사용했을때 “Hello, world!” 바이너리를 만들어준 것과 사뭇
다릅니다. <code>#[]</code>와 <code>mod tests</code> 문법은 이 장의 “<code>super</code>를 이용하여 부모 모듈에
접근하기”절에서 더 자세히 다룰 것이지만, 당장은 <em>src/lib.rs</em>의 아래쪽에 이 코드를
남겨두겠습니다.</p>
<p><em>src/main.rs</em> 파일이 없기 때문에, <code>cargo run</code> 커맨드로 카고가 실행할 것이 없습니다.
따라서, 여기서는 라이브러리 크레이트의 코드를 컴파일하기 위해 <code>cargo build</code>를 사용할
것입니다.</p>
<p>이제 여러분이 작성하는 코드의 의도에 따라 만들어지는 다양한 상황에 알맞도록 라이브러리
코드를 조직화하는 다양한 옵션들을 살펴보겠습니다.</p>
<h3 id="모듈-정의"><a class="header" href="#모듈-정의">모듈 정의</a></h3>
<p>우리의 <code>communicator</code> 네트워크 라이브러리를 위해서, 먼저 <code>connect</code>라는 이름의 함수가
정의되어 있는 <code>network</code>라는 이름의 모듈을 정의하겠습니다. 러스트 내 모듈 정의는 모두
<code>mod</code>로 시작됩니다. 이 코드를 <em>src/lib.rs</em>의 시작 부분, 즉 테스트 코드의 윗 쪽에
추가해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod network {
    fn connect() {
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>mod</code> 키워드 뒤에, 모듈의 이름 <code>network</code>가 쓰여지고 중괄호 안에 코드 블록이 옵니다.
이 블록 안의 모든 것은 이름공간 <code>network</code> 안에 있습니다. 위의 경우 <code>connect</code>라는
이름의 함수 하나가 있습니다. 이 함수를 <code>network</code> 모듈 바깥의 스크립트에서 호출하고자
한다면, 우리는 모듈을 특정할 필요가 있으므로 이름공간 문법 <code>::</code>를 이용해야 합니다:
<code>connect()</code> 이렇게만 하지 않고 <code>network::connect()</code> 이런 식으로요.</p>
<p>또한 같은 <em>src/lib.rs</em> 파일 내에 여러 개의 모듈을 나란히 정의할 수도 있습니다.
예를 들어, <code>connect</code>라는 이름의 함수를 갖고 있는 <code>client</code> 모듈을 정의하려면,
Listing 7-1에 보시는 바와 같이 이를 추가할 수 있습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 7-1: <em>src/lib.rs</em> 내에 나란히 정의된 <code>network</code>
모듈과 <code>client</code> 모듈</span></p>
<p>이제 우리는 <code>network::connect</code> 함수와 <code>client::connect</code> 함수를 갖게 되었습니다.
이들은 완전히 다른 기능을 갖고 있을 수 있고, 서로 다른 모듈에 정의되어 있기 때문에
함수 이름이 서로 부딪힐 일은 없습니다.</p>
<p>이 경우, 우리가 라이브러리를 만드는 중이기 때문에, 라이브러리의 시작 지점으로서
제공되는 파일은 <em>src/lib.rs</em> 입니다. 하지만 모듈을 만드는 것에 관하여
<em>src/lib.rs</em>는 특별할 것이 없습니다. 우리는 라이브러리 크레이트의 <em>src/lib.rs</em> 내에
모듈을 만드는 것과 똑같은 방식으로 바이너리 크레이트의 <em>src/main.rs</em> 내에도 모듈을
만들 수 있습니다. 사실 모듈 안에 다른 모듈을 집어넣는 것도 가능한데, 이는 여러분의
모듈이 커짐에 따라 관련된 기능이 잘 조직화 되도록 하는 한편 각각의 기능을 잘 나누도록
하는데 유용할 수 있습니다. 여러분의 코드를 어떻게 조직화 할 것인가에 대한 선택은
여러분이 코드의 각 부분 간의 관계에 대해 어떻게 생각하고 있는지에 따라 달라집니다.
예를 들어, Listing 7-2와 같이 <code>client</code> 모듈과 <code>connect</code> 함수가 <code>network</code> 이름공간
내에 있다면 우리의 라이브러리 사용자가 더 쉽게 이해할지도 모릅니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 7-2: <code>client</code> 모듈을 <code>network</code> 모듈 안으로 이동</span></p>
<p><em>src/lib.rs</em> 파일에서 Listing 7-2와 같이 <code>client</code> 모듈이 <code>network</code> 모듈의
내부 모듈이 되도록 <code>mod network</code>와 <code>mod client</code>의 위치를 바꿔 봅시다. 이제
우리는 <code>network::connect</code>와 <code>network::client::connect</code> 함수를 갖게 되었습니다:
다시 말하지만, <code>connect</code>라는 이름의 두 함수는 서로 다른 이름공간에 있으므로
부딪힐 일이 없습니다.</p>
<p>이런 식으로 모듈들은 계층을 구성하게 됩니다. <em>src/lib.rs</em>의 내용은 가장 위의 층을
이루고, 서브 모듈들은 그보다 낮은 층에 있습니다. Listing 7-1 예제에서의 조직화가
계층 구조를 생각했을 때 어떻게 보일지 살펴봅시다:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>그리고 Listing 7-2 예제에 대응되는 계층 구조는 이렇습니다:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>Listing 7-2에서 계층 구조는 <code>client</code>가 <code>network</code>의 형제이기 보다는 자식임을
보여줍니다. 더 복잡한 프로젝트는 많은 수의 모듈을 갖고 있을 수 있고, 이들은 지속적인
트래킹을 위해 논리적으로 잘 조직화될 필요가 있을 것입니다. 여러분의 프로젝트 내에서
“논리적으로”가 의미하는 것은 여러분에게 달려 있는 것이며, 여러분과 여러분의 라이브러리
사용자들이 프로젝트 도메인에 대해 어떻게 생각하는지에 따라 달라집니다. 여러분이 선호하는
어떤 형태의 구조이건 간에 여기서 보여준 나란한 모듈 및 중첩된(nested) 모듈을 만드는
테크닉을 이용해 보세요.</p>
<h3 id="모듈을-다른-파일로-옮기기"><a class="header" href="#모듈을-다른-파일로-옮기기">모듈을 다른 파일로 옮기기</a></h3>
<p>모듈은 계층적인 구조를 형성하는데, 여러분이 익숙하게 사용하고 있는 다른 구조와 매우 닮았습니다: 바로
파일 시스템이죠! 러스트에서는 프로젝트를 잘게 나누기 위해 여러 개의 파일 상에서 모듈 시스템을 사용할
수 있어, 모든 것들이 <em>src/lib.rs</em>나 <em>src/main.rs</em> 안에 존재하지 않게할 수 있습니다. 이러한
예를 위해서, Listing 7-3에 있는 코드를 시작해봅시다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 7-3: 세 개의 모듈 <code>client</code>, <code>network</code>, <code>network::server</code>가
모두 <em>src/lib.rs</em>에 정의되어 있음</span></p>
<p>파일 <em>src/lib.rs</em>는 아래와 같은 모듈 계층을 갖고 있습니다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>만일 이 모듈들이 여러 개의 함수들을 갖고 있고, 이 함수들이 길어지고 있다면, 우리가 작업하고자 하는
코드를 찾으려고 이 파일을 스크롤 하기가 까다로워질 것입니다. 함수들은 하나 혹은 그 이상의 <code>mod</code> 블록
안에 포함되어 있기 때문에, 함수 내의 코드 라인들 또한 길어지기 시작할 것입니다. 이는 <code>client</code>,
<code>network</code>, 그리고 <code>server</code> 모듈을 <em>src/lib.rs</em>로부터 떼어내어 각자를 위한 파일들에 위치시키기
좋은 이유가 되겠습니다.</p>
<p>먼저 <code>client</code> 모듈의 코드를 <code>client</code> 모듈의 선언 부분만 남겨두는 것으로 바꾸세요. 그러니까 여러분의
<em>src/lib.rs</em>는 아래와 같이 될 것입니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}</code></pre>
<p>여기서는 여전히 <code>client</code> 모듈을 <em>선언</em>하고 있지만, 코드 블록을 세미콜론으로 대체함으로써, 우리는
러스트에게 <code>client</code> 모듈의 스코프 내에 정의된 코드를 다른 위치에서 찾으라고 말하는 것입니다. 달리
말하면, <code>mod client;</code>라는 라인의 뜻은 이렇습니다:</p>
<pre><code class="language-rust ignore">mod client {
    // contents of client.rs
}</code></pre>
<p>이제 모듈의 이름과 같은 이름을 가진 외부 파일을 만들 필요가 있습니다. <em>client.rs</em> 파일을 여러분의
<em>src/</em> 디렉토리에 생성하고 여세요. 그런 뒤 아래와 같이 앞 단계에서 제거했던 <code>client</code> 모듈내의
<code>connect</code> 함수를 입력해세요:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn connect() {
}
<span class="boring">}</span></code></pre></pre>
<p>이미 <em>src/lib.rs</em> 안에다 <code>client</code> 모듈을 <code>mod</code>를 이용하여 선언을 했기 때문에,
이 파일 안에는 <code>mod</code> 선언이 필요없다는 점을 기억하세요. 이 파일은 단지 <code>client</code> 모듈의 <em>내용물</em>만
제공할 뿐입니다. 만일 <code>mod client</code>를 여기에 또 집어넣는다면, 이는 <code>client</code> 모듈 내에 서브모듈
<code>client</code>를 만들게 됩니다!</p>
<p>러스트는 기본적으로 <em>src/lib.rs</em>만 찾아볼줄 압니다. 만약에 더 많은 파일을 프로젝트에 추가하고
싶다면, <em>src/lib.rs</em> 내에서 다른 파일을 찾아보라고 러스트에게 말해줄 필요가 있습니다; 이는
<code>mod client</code>라는 코드가 왜 <em>src/lib.rs</em> 내에 정의될 필요가 있는지, 그리고 <em>src/client.rs</em>
내에는 정의될 수 없는지에 대한 이유입니다.</p>
<p>이제 몇 개의 컴파일 경고가 생기지만, 프로젝트는 성공적으로 컴파일 되어야 합니다. 우리가 바이너리 크레이트
대신 라이브러리 크레이트를 만드는 중이므로 <code>cargo run</code> 대신 <code>cargo build</code>를 이용해야 한다는 점을
기억해두세요:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/client.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:4:5
  |
4 |     fn connect() {
  |     ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:8:9
  |
8 |         fn connect() {
  |         ^
</code></pre>
<p>이 경고들은 사용된 적이 없는 함수가 있음을 우리에게 알려줍니다. 지금은 이 경고들을 너무 걱정하지 마세요:
이 장의 뒤에 나오는 “<code>pub</code>을 이용하여 가시성 제어하기”절에서 이 문제에 대해 알아볼 것입니다. 좋은 소식은
이들이 그냥 경고일 뿐이란 것입니다; 우리 프로젝트는 성공적으로 빌드됐습니다!</p>
<p>다음으로 같은 방식을 이용하여 <code>network</code> 모듈을 개별 파일로 추출해봅시다. <em>src/lib.rs</em> 안에서,
아래와 같이 <code>network</code> 모듈의 몸체를 지우고 선언부의 끝부분에 세미콜론을 붙이세요:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;</code></pre>
<p>그리고나서 새로운 <em>src/network.rs</em> 파일을 만들어서 아래를 입력하세요:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn connect() {
}

mod server {
    fn connect() {
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이 모듈 파일 내에는 <code>mod</code> 선언이 여전히 있음을 주목하세요; 이는 <code>server</code>가 <code>network</code>의 서브모듈로서
여전히 필요하기 때문입니다.</p>
<p><code>cargo build</code>를 다시 실행시키세요. 성공! 여기 또 추출할만한 모듈이 하나 더 있습니다: <code>server</code> 말이죠.
이것이 서브모듈(즉, 모듈 내의 모듈)이기 때문에, 모듈을 파일로 추출해서 파일 이름을 모듈 이름으로 사용하는
전략은 사용하기 힘듭니다. 어쨌든 시도해서 에러를 확인해보겠습니다. 먼저, <em>src/network.rs</em> 내에서
<code>server</code> 모듈의 내용물 대신에 <code>mod server</code>을 쓰세요:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;</code></pre>
<p>그후 <em>src/server.rs</em> 파일을 만들고 추출해둔 <code>server</code> 모듈의 내용물을 입력하세요:</p>
<p><span class="filename">Filename: src/server.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn connect() {
}
<span class="boring">}</span></code></pre></pre>
<p><code>cargo build</code>를 실행해보면, Listing 7-4와 같은 에러를 얻게 됩니다:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `network` to its own directory via `network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listing 7-4: <code>server</code> 서브모듈을 <em>src/server.rs</em>로 추출을 시도했을 때
발생하는 에러</span></p>
<p>에러는 <code>이 위치에 새로운 모듈을 선언할수 없다</code>고 말해주며 <em>src/network.rs</em>의 <code>mod server;</code>
라인을 지적하고 있습니다. <em>src/network.rs</em>는 <em>src/lib.rs</em>와는 다소 다릅니다: 왜 그런지
이해하려면 계속 읽어주세요.</p>
<p>Listing 7-4의 중간의 노트는 실질적으로 매우 도움이 되는데, 그 이유는 우리가 아직 설명하지 않은
무언가를 지적하고 있기 때문입니다:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>전에 사용했던 똑같은 파일 이름 쓰기 패턴을 계속해서 따르는 대신, 아래 노트에서 제안하는 것을 해볼
수 있습니다:</p>
<ol>
<li>부모 모듈의 이름에 해당하는, <em>network</em>라는 이름의 새로운 <em>디렉토리</em>를 만드세요.</li>
<li><em>src/network.rs</em> 파일을 이 새로운 <em>network</em> 디렉토리 안으로 옮기고, 파일 이름을
<em>src/network/mod.rs</em>로 고치세요.</li>
<li>서브모듈 파일 <em>src/server.rs</em>를 <em>network</em> 디렉토리 안으로 옮기세요.</li>
</ol>
<p>위의 단계들을 실행하기 위한 명령들입니다:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>이제 <code>cargo build</code>를 다시 실행하면, 컴파일은 작동할 것입니다 (여전히 경고는 좀 있지만요). 우리의
모듈 레이아웃은 여전히 아래와 같이 되는데, 이는 Listing 7-3의 <em>src/lib.rs</em> 내의 코드에서 만든 것과
정확하게 동일합니다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>이에 대응하는 파일 레이아웃는 아래와 같이 생겼습니다:</p>
<pre><code class="language-text">├── src
│   ├── client.rs
│   ├── lib.rs
│   └── network
│       ├── mod.rs
│       └── server.rs
</code></pre>
<p>그러니까 우리가 <code>network::server</code> 모듈을 추출하고자 할 때, 왜 <code>network::server</code> 모듈을
<em>src/server.rs</em>로 추출하는 대신, <em>src/network.rs</em> 파일을 <em>src/network/mod.rs</em>로 바꾸고
<code>network::server</code> 코드를 <em>network</em> 디렉토리 안에 있는 <em>src/network/server.rs</em>에 넣었을까요?
그 이유는 <em>src</em> 디렉토리 안에 <em>server.rs</em> 파일이 있으면, 러스트는 <code>server</code>가 <code>network</code>의
서브모듈이라고 인식할 수 없기 때문입니다. 러스트가 동작하는 방식을 명확하게 알기 위해서, 아래와 같은 모듈
계층 구조를 가진, <em>src/lib.rs</em> 내에 모든 정의가 다 들어있는 다른 예제를 봅시다:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── client
</code></pre>
<p>이 예제에는 또다시 <code>client</code>, <code>network</code>, 그리고 <code>network::client</code>라는 세 개의 모듈이 있습니다.
모듈을 파일로 추출하기 위해 앞서 했던 단계를 따르면, <code>client</code> 모듈을 위한 <em>src/client.rs</em>을
만들게 될 것입니다. <code>network</code> 모듈을 위해서는 <em>src/network.rs</em> 파일을 만들게 될 것입니다.
하지만 <code>network::client</code> 모듈을 <em>src/client.rs</em>로 추출하는 것은 불가능한데, 그 이유는
최상위 층에 <code>client</code> 모듈이 이미 있기 때문이죠! 만일 <code>client</code>와 <code>network::client</code> 모듈
<em>둘다</em> <em>src/client.rs</em> 파일에 집어넣는다면, 러스트는 이 코드가 <code>client</code>를 위한 것인지,
아니면 <code>network::client</code>를 위한 것인지 알아낼 방법이 없을 것입니다.</p>
<p>따라서, <code>network</code> 모듈의 <code>network::client</code> 서브모듈을 위한 파일을 추출하기 위해서는
<em>src/network.rs</em> 파일 대신 <code>network</code> 모듈을 위한 디렉토리를 만들 필요가 있습니다. <code>network</code>
모듈 내의 코드는 그후 <em>src/network/mod.rs</em> 파일로 가고, 서브모듈 <code>network::client</code>은
<em>src/network/client.rs</em> 파일을 갖게할 수 있습니다. 이제 최상위 층의 <em>src/client.rs</em>는
모호하지 않게 <code>client</code> 모듈이 소유한 코드가 됩니다.</p>
<h3 id="모듈-파일-시스템의-규칙"><a class="header" href="#모듈-파일-시스템의-규칙">모듈 파일 시스템의 규칙</a></h3>
<p>파일에 관한 모듈의 규칙을 정리해봅시다:</p>
<ul>
<li>만일 <code>foo</code>라는 이름의 모듈이 서브모듈을 가지고 있지 않다면, <em>foo.rs</em>라는 이름의 파일 내에
<code>foo</code>에 대한 선언을 집어넣어야 합니다.</li>
<li>만일 <code>foo</code>가 서브모듈을 가지고 있다면, <em>foo/mod.rs</em>라는 이름의 파일에 <code>foo</code>에 대한 선언을
집어넣어야 합니다.</li>
</ul>
<p>이 규칙들은 재귀적으로 적용되므로, <code>foo</code>라는 이름의 모듈이 <code>bar</code>라는 이름의 서브모듈을 갖고 있고
`bar는 서브모듈이 없다면, 여러분의 <em>src</em> 디렉토리 안에는 아래와 같은 파일들이 있어야 합니다:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contains the declarations in `foo::bar`)
│   └── mod.rs (contains the declarations in `foo`, including `mod bar`)
</code></pre>
<p>이 모듈들은 부모 모듈의 파일에 <code>mod</code> 키워드를 사용하여 선언되어 있어야 합니다.</p>
<p>다음으로, <code>pub</code> 키워드에 대해 알아보고 앞의 그 경고들을 없애봅시다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-00-modules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch07-02-controlling-visibility-with-pub.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-00-modules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch07-02-controlling-visibility-with-pub.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
