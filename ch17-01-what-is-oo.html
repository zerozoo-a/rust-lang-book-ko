<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>객체 지향 언어의 특성 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입들</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수 동작 원리</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 이용해 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install을 이용해 Crates.io에서 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 Cargo 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운팅 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메세지 패싱</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 확장 가능한 동시성: Sync와 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html" class="active"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법의 모든 것</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 고급 라이프타임</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 고급 트레잇</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 고급 함수와 클로저</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자 및 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - derive 가능한 트레잇</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 매크로</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 본 책의 번역본 목록</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 새로운 기능</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-glossary.html"><strong aria-hidden="true">21.8.</strong> H - 번역 용어 정리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="객체-지향-언어의-특성"><a class="header" href="#객체-지향-언어의-특성">객체 지향 언어의 특성</a></h2>
<p>객체 지향적인 언어가 반드시 갖춰야 할 기능에 대해 프로그래밍 커뮤니티들은
의견 일치를 보지 못하고 있습니다. 러스트는 OOP도 포함하여 많은
프로그래밍 패러다임에 영향을 받았습니다; 예를 들면, 우리가 13장에서
살펴본 기능인 함수형 프로그래밍에서 온 기능들 말이지요. OOP 언어라면
거의 틀림없이 몇가지 공통적인 특성을 공유하는데, 객체, 캡슐화 및 상속이
있습니다. 이 특성들이 각각 뜻하는 것과 러스트가 이를 지원하는지에
대해 살펴봅시다.</p>
<h3 id="객체는-데이터와-동작을-담습니다"><a class="header" href="#객체는-데이터와-동작을-담습니다">객체는 데이터와 동작을 담습니다</a></h3>
<p>흔히 The Gang of Four라고도 불리우는 Erich Gamma, Richard Helm, Ralph Johnson,
그리고 John Vlissides (Addison-Wesley Professional, 1994)의 책 <em>Design Patterns:
Elements of Reusable Object-Oriented Software</em>은 객체 지향 디자인 패턴의 편람입니다.
이 책에서는 OOP를 다음과 같이 정의합니다.</p>
<blockquote>
<p>객체-지향 프로그램은 객체로 구성된다. <em>객체</em>는 데이터 및 이 데이터를
활용하는 프로시저를 묶는다. 이 프로시저들은 보통 <em>메소드</em> 혹은
<em>연산 (operation)</em> 으로 불린다.</p>
</blockquote>
<p>이 정의에 따르면, 러스트는 객체 지향적입니다: 구조체와 열거형은 데이터를 갖고,
<code>impl</code> 블럭은 그 구조체와 열거형에 대한 메소드를 제공하죠. 설령 메소드를 갖는
구조체와 열거형을 객체라고 <em>호칭</em>하지 않더라도, 그들은 동일한 기능을 수행하며,
이는 Gang of Four의 객체에 대한 정의를 따릅니다.</p>
<h3 id="상세-구현을-은닉하는-캡슐화"><a class="header" href="#상세-구현을-은닉하는-캡슐화">상세 구현을 은닉하는 캡슐화</a></h3>
<p>일반적으로 OOP와 관련된 또다른 면은 캡슐화로, 그 의미는 객체를
이용하는 코드에서 그 객체의 상세 구현에 접근할 수 없게 한다는
것입니다. 따라서, 유일하게 객체와 상호작용하는 방법은 이것의
공개 API를 통하는 것입니다; 객체를 사용하는 코드는 직접 객체의
내부에 접근하여 데이터나 동작을 변경해서는 안됩니다. 이는 프로그래머가
객체를 사용하는 코드의 변경없이 이 객체 내부를 변경하거나 리팩토링할
수 있도록 해줍니다. </p>
<p>우리는 7장에서 어떻게 캡슐화를 제어하는지에 대해 논의했습니다: 우리는 <code>pub</code>
키워드를 사용하여 어떤 모듈들, 타입들, 함수들, 그리고 메소드들이 공개될 것인가를
결정할 수 있으며, 기본적으로는 모든 것들이 비공개입니다. 예를 들면, 우리는 <code>i32</code>
값의 벡터 항목을 가지고 있는 <code>AveragedCollection</code> 구조체를 정의할 수
있습니다. 또한 이 구조체는 벡터의 값에 대한 평균값을 담는 항목도 갖는데,
이는 누구든 평균값이 필요한 순간마다 매번 이를 계산할 필요는 없음을 의미합니다.
바꿔 말하면, <code>AveragedCollection</code>은 우리를 위해 계산된 평균값을 캐쉬할
것입니다. Listing 17-1가 이 <code>AveragedCollection</code> 구조체에 대한
정의입니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 17-1: 콜렉션 내의 정수
항목들과 그의 평균을 관리하는 <code>AveragedCollection</code>
구조체</span></p>
<p>구조체가 <code>pub</code>으로 표기되면 다른 코드가 이를 사용할 수 있게 되지만, 구조체 안에 존재하는
항목들은 여전히 비공개입니다. 이는 이번 사례에 매우 중요한데, 그 이유는 하나의 값이
리스트에서 더해지거나 제거될 때마다 평균 또한 갱신되는 것을 확신하길 원하기 때문입니다.
우리는 <code>add</code>, <code>remove</code>, 그리고 <code>average</code> 메소드를 구조체에 구현하여 이를 달성하고자
하며, 이는 Listing 17-2과 같습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 17-2: <code>AveragedCollection</code>의 공개 메소드 <code>add</code>,
<code>remove</code>, 그리고 <code>average</code></span></p>
<p>공개 메소드들 <code>add</code>, <code>remove</code>, 그리고 <code>average</code>는 <code>AveragedCollection</code>의
인스턴스를 수정하는 유일한 방법입니다. 아이템이 <code>list</code>에 <code>add</code> 메소드를 통해
추가되거나 <code>remove</code> 메소드를 통해 제거될 때, 각각의 호출은 비공개
<code>update_average</code> 메소드를 호출하여 <code>average</code> 필드를 변경하도록 하는
역할 또한 수행합니다.</p>
<p>우리가 <code>list</code>와 <code>average</code> 필드를 비공개로 두었으므로 외부 코드가
<code>list</code> 필드에 직접 아이템들을 추가하거나 제거할 방법은 없습니다;
그렇지 않으면, <code>average</code> 필드는 <code>list</code>가 변경될 때 동기화되지 않을지도
모릅니다. <code>average</code> 메소드는 <code>average</code> 필드의 값을 반환하여,
외부 코드가 <code>average</code>를 읽을 수 있도록 하지만, 변경은 안됩니다. </p>
<p>우리가 <code>AveragedCollection</code>의 내부 구현을 캡슐화했기 때문에,
차후에 데이터 구조 등을 쉽게 변경할 수 있습니다. 예를 들면,
우리는 <code>list</code> 필드에 대해서 <code>Vec&lt;i32&gt;</code>가 아닌 <code>HashSet&lt;i32&gt;</code>를
사용할 수 있습니다. <code>add</code>, <code>remove</code> 그리고 <code>average</code> 공개 메소드들의
선언이 그대로 유지되는 한, <code>AveragedCollection</code>를 사용하는 코드들은
변경될 필요가 없습니다. 대신 우리가 <code>list</code>를 공개했다면 꼭 그런 상황이
될 수는 없을 것입니다: <code>HashSet&lt;i32&gt;</code>와 <code>Vec&lt;i32&gt;</code>는 아이템들을
추가하거나 제거하기 위한 메소드들이 다르므로, 만약 <code>list</code>에 직접 접근하여
변경하는 방식의 외부 코드들이 있다면 모두 변경되어야겠죠.</p>
<p>만약 캡슐화가 객체 지향을 염두하는 언어를 위한 필요 요소라면,
러스트는 이를 만족합니다. 코드의 서로 다른 부분들에 대해 <code>pub</code>을
사용하거나 사용하지 않는 옵션이 구현 세부 사항의 캡슐화를 가능케 합니다. </p>
<h3 id="타입-시스템과-코드-공유로서의-상속"><a class="header" href="#타입-시스템과-코드-공유로서의-상속">타입 시스템과 코드 공유로서의 상속</a></h3>
<p><em>상속</em>은 어떤 객체가 다른 객체의 정의를 상속받아서, 이를 통해 부모
객체의 데이터와 동작들을 다시 정의하지 않고도 얻을 수 있게 해주는
메커니즘입니다.</p>
<p>만약 객체 지향 언어가 반드시 상속을 제공해야 한다면, 러스트는
그렇지 않은 쪽입니다. 부모 구조체의 필드와 메소드 구현을 상속받는
구조체를 정의할 방법은 없습니다. 하지만 여러분이 상속에 익숙하다면,
우선 이를 사용하고자 하는 이유에 따라 러스트의 다른 솔루션들을
이용할 수 있습니다.</p>
<p>여러분은 두가지 주요한 이유에 의해 상속을 택합니다. 하나는 코드를 재사용하는
것입니다: 여러분은 어떤 타입의 특정한 행위를 구현할 수 있고, 상속은 당신이
다른 타입을 위해 그 구현을 재사용할 수 있도록 만들어줍니다. 여러분은 대신
기본 트레잇 메소드의 구현을 이용하여 러스트 코드를 공유할 수 있는데, 이는
Listing 10-14에서 우리가 <code>Summary</code> 트레잇에 <code>summarize</code> 메소드의
기본 구현을 추가할 때 봤던 것입니다. <code>Summary</code> 트레잇을 구현하는 어떤
타입이든, <code>summarize</code> 메소드를 별도로 작성하지 않더라도 사용 가능합니다.
이는 어떤 메소드의 구현체를 갖는 부모 클래스와 그를 상속받는 자식 클래스
또한 그 메소드의 해당 구현체를 갖는 것과 유사합니다. 우리는 또한 <code>Summary</code>
트레잇을 구현할 때 <code>summarize</code>의 기본 구현을 오버라이딩할 수 있고,
이는 자식 클래스가 부모 클래스에서 상속받는 메소드를 오버라이딩하는 것과
유사합니다.</p>
<p>상속을 사용하는 다른 이유는 타입 시스템과 관련있습니다: 자식 타입을 같은
위치에서 부모 타입처럼 사용할 수 있게 하기 위함입니다. 이를 또한
<em>다형성 (polymorphism)</em> 이라고도 부르는데, 이는 여러 객체들이 일정한 특성을
공유한다면 이들을 런타임에 서로 바꿔 대입하여 사용할 수 있음을 의미합니다.</p>
<blockquote>
<h3 id="다형성"><a class="header" href="#다형성">다형성</a></h3>
<p>많은 사람들이 다형성을 상속과 동일시 합니다. 하지만 다형성은 다수의
타입들의 데이터에 대해 동작 가능한 코드를 나타내는 더 범용적인 개념입니다.
상속에서는 이런 타입들이 일반적으로 하위클래스에 해당합니다.</p>
<p>러스트는 대신 제네릭을 사용하여 호환 가능한 타입을 추상화하고 트레잇 바운드를
이용하여 해당 타입들이 반드시 제공해야 하는 제약사항을 부과합니다. 이것을 종종
<em>범주내 매개변수형 다형성 (bounded parametric polymophism)</em> 이라고 부릅니다. </p>
</blockquote>
<p>최근에는 상속이 많은 프로그래밍 언어에서 프로그래밍 디자인
솔루션으로서의 인기가 떨어지고 있는데 그 이유는 필요한 것보다 더
많은 코드를 공유할 수 있는 위험이 있기 때문입니다. 하위 클래스가
늘 그들의 부모 클래스의 모든 특성을 공유해서는 안되지만 상속한다면
그렇게 됩니다. 이는 프로그램의 유연성을 저하시킬 수 있습니다. 또한,
하위 클래스에서는 타당하지 않거나 적용될 수 없어서 에러를 유발하는
메소드들이 호출될 수 있는 가능성을 만듭니다. 게다가, 어떤 언어들은
하나의 클래스에 대한 상속만을 허용하기 때문에 프로그램 디자인의
유연성을 더욱 제한하게 됩니다.</p>
<p>이런 이유로, 러스트는 다른 방식을 취하여, 상속 대신에 트레잇 객체를 사용합니다.
러스트에서 어떤 식으로 트레잇 객체가 다형성을 가능케 하는지 살펴봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-00-oop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch17-02-trait-objects.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-00-oop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch17-02-trait-objects.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
